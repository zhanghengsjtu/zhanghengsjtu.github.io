<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张恒的博客</title>
  
  
  <link href="http://zhanghengsjtu.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhanghengsjtu.github.io/"/>
  <updated>2021-07-22T01:10:01.037Z</updated>
  <id>http://zhanghengsjtu.github.io/</id>
  
  <author>
    <name>张恒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ROS基础：命名空间和重映射</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E9%87%8D%E6%98%A0%E5%B0%84/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E9%87%8D%E6%98%A0%E5%B0%84/</id>
    <published>2021-07-21T05:55:25.000Z</published>
    <updated>2021-07-22T01:10:01.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>主要有四种命名方式，分为基础，全局，相对和私有。</p><ul><li><strong>基础</strong>：用来描述资源自身，可以当做相对名称的一个子类；</li><li><strong>全局</strong>：如<code>/joint_sates</code>中的<code>/</code>或者在launch文件中，通过<code>ns=&quot;sim1&quot;</code>设置；</li><li><strong>相对</strong>：在节点<code>node1</code>下面的话题<code>topic1</code>，如果其全局空间为<code>sim1</code>，则变成<code>/sim1/topic1</code></li><li><strong>私有</strong>：在节点<code>node1</code>下面的话题<code>~topic1</code>，如果其全局空间为<code>sim1</code>，则变成<code>/sim1/node1/topic1</code>，注意和相对的区别</li></ul><h4 id="命名映射"><a href="#命名映射" class="headerlink" title="命名映射"></a>命名映射</h4><p>命名映射的基本语法是： <code>name:=new_name</code>。同样的，重映射的规则与名称的全局和相对特性有关系。规则参考如下：<br><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210718223225.png" alt="ros命名映射"></p>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：catkin编译系统</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Acatkin%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Acatkin%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-21T05:52:06.000Z</published>
    <updated>2021-07-22T01:09:20.954Z</updated>
    
    <content type="html"><![CDATA[<p>ROS使用catkin来管理包，它是对CMake的扩展。一个catkin软件包必须要有package.xml和CMakeLists.txt两个文件，前者包括了包的描述和依赖信息，后者是构建包的cmake文件。实际工作中，catkin工具会调用CMakeLists.txt，而生成makefile等文件。</p><h4 id="package-xml基本结构"><a href="#package-xml基本结构" class="headerlink" title="package.xml基本结构"></a><a href="http://wiki.ros.org/catkin/package.xml">package.xml基本结构</a></h4><p>一个典型的package.xml文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;package format=&quot;2&quot;&gt;</span><br><span class="line">  &lt;name&gt;your_package&lt;/name&gt;</span><br><span class="line">  &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">  &lt;description&gt;</span><br><span class="line">    This package adds extra features to rosawesome.</span><br><span class="line">  &lt;/description&gt;</span><br><span class="line">  &lt;maintainer email=&quot;you@example.com&quot;&gt;Your Name&lt;/maintainer&gt;</span><br><span class="line">  &lt;license&gt;BSD&lt;/license&gt;</span><br><span class="line">  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line">  &lt;depend&gt;roscpp&lt;/depend&gt;</span><br><span class="line">  &lt;build_depend&gt;angles&lt;/build_depend&gt;</span><br><span class="line">  &lt;build_export_depend&gt;angles&lt;/build_export_depend&gt;</span><br><span class="line">  &lt;exec_depend&gt;openni_launch&lt;/exec_depend&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure><p>几个重要的标签，解释如下：</p><ol><li><code>buildtool_depend</code>: 编译工具，默认<code>catkin</code>，一般不用修改。</li><li><code>depend</code>：指定编译时的依赖项，包含<code>build_depend</code>，<code>build_export_depend</code>和<code>exec_depend</code>。</li><li><code>build_depend</code>: 指定编译功能包需要的依赖，例如<code>angle</code>包提供了C++头文件和编译文件。</li><li><code>build_export_depend</code>: 指定对功能包构建库需要的依赖，例如本功能包导出的头文件依赖了<code>&lt;angles/angles.h&gt;</code>，那么第三方包使用本包导出的头文件时，仍然需要<code>&lt;build_depend&gt;angles&lt;/build_depend&gt;</code>。</li><li><code>exec_depend</code>: 指定运行该功能包需要的依赖。</li><li><strong>建议</strong>：简单情况直接使用<code>depend</code>标签即可（一个顶仨），也不容易出错；如果是依赖的系统项，可以根据<a href="https://docs.ros.org/en/kinetic/api/catkin/html/howto/format2/index.html">官方建议</a>谨慎选择。</li></ol><h4 id="CMakeLists-txt的基本结构"><a href="#CMakeLists-txt的基本结构" class="headerlink" title="CMakeLists.txt的基本结构"></a><a href="http://wiki.ros.org/catkin/CMakeLists.txt">CMakeLists.txt的基本结构</a></h4><p>CMake是不知道package.xml中的依赖关系的，但是catkin知道，因此在CMakeLists.txt中需要对catkin合理配置，便于处理包的依赖关系。<br>CMakeLists.txt基本结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.3)</span><br><span class="line">project(robot_brain)</span><br><span class="line"># Get the information about this package&#x27;s buildtime dependencies</span><br><span class="line">find_package(catkin REQUIRED</span><br><span class="line">  COMPONENTS message_generation std_msgs sensor_msgs)</span><br><span class="line"></span><br><span class="line"># Declare the message files to be built</span><br><span class="line">add_message_files(FILES</span><br><span class="line">  MyMessage.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Declare the service files to be built</span><br><span class="line">add_service_files(FILES</span><br><span class="line">  MyService.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Actually generate the language-specific message and service files</span><br><span class="line">generate_messages(DEPENDENCIES std_msgs sensor_msgs)</span><br><span class="line"></span><br><span class="line"># Declare that this catkin package&#x27;s runtime dependencies</span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS message_runtime std_msgs sensor_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_executable(message_program src/main.cpp)</span><br><span class="line">add_dependencies(message_program $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS)</span><br><span class="line">target_link_libraries(message_program $&#123;catkin_LIBRARIES&#125; other_lib)</span><br></pre></td></tr></table></figure><p>重要的模块解释如下：</p><ol><li><code>find_package</code>: cmake宏，指定依赖的其他pacakge，实际是生成了一些环境变量，如NAME_FOUND，NAME_INCLUDE_DIRS, NAME_LIBRARYIS，此处catkin是必备依赖 其余的syd_msgs…为组件，这个里面的包在package.xml中一定要有<code>build_depend</code>标签。</li><li><code>catkin_package</code>：catkin宏，生成当前package的cmake配置，供依赖本包的其他软件包调用，同时这个命令必须在add_library()或者add_executable()之前调用；注意这个里面的包在package.xml一定要有<code>build_export_depend</code>标签。</li><li>其余为CMake自身语法，具体可以参考<a href="https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf">CMake学习资料</a>。</li></ol><h4 id="创建msg的注意事项"><a href="#创建msg的注意事项" class="headerlink" title="创建msg的注意事项"></a>创建msg的注意事项</h4><ul><li>在package.xml中<ol><li><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</code></li><li><code>&lt;build_export_depend&gt;message_runtime&lt;/build_export_depend&gt;</code></li><li><code>&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code></li></ol></li><li>在CMakeLists.txt中<ol><li>添加<code>find_package(messaga_generation)</code>，确保可以生成msg文件；</li><li>添加<code>catkin_package(message_runtime)</code>：确保生成的msgs文件可以被外部使用；</li><li>添加<code>add_message_file</code>，添加具体的文件名；</li><li>添加<code>generate_message</code>中的依赖包，如依赖<code>std_msgs</code></li></ol></li></ul>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：launch文件</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Alaunch%E6%96%87%E4%BB%B6/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Alaunch%E6%96%87%E4%BB%B6/</id>
    <published>2021-07-18T09:39:58.000Z</published>
    <updated>2021-07-21T07:06:07.508Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录launch文件学习细节</li></ul>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：常用命令</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-07-18T09:34:44.000Z</published>
    <updated>2021-07-22T00:20:39.422Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">echo $ROS_PACKAGE_PATH  </span><br><span class="line"># 打印ros环境变量，确保/opt/ros/kinetic/share和自己的工作空间在里面</span><br><span class="line"># 同时注意ROS中存在工作空间覆盖的机制，即后设置的路径会放在ROS_PACKAGE_PATH前面</span><br><span class="line"># 实际工作时，系统在ROS_PACKAGE_PATH中从前向后查找对应的包，找到即停止</span><br><span class="line"></span><br><span class="line"># 编译相关</span><br><span class="line">catkin_init_workspace       # 在一个空的文件夹下面初始化一个工作空间</span><br><span class="line">catkin_make                 # 编译对应的工作空间</span><br><span class="line">catkin build -j4            # 编译对应的工作空间，-j4指定用4个核，相比catkin_make，输出信息更丰富</span><br><span class="line">catkin_create_pkg pkg_name dep1 dep2 dep3   # 创建包，并指定依赖</span><br><span class="line"></span><br><span class="line"># 话题相关</span><br><span class="line">rosmsg show msg_type        # 查看消息类型</span><br><span class="line">rostopic list               # 查看话题名称</span><br><span class="line">rostopic type topic_name    # 查看话题数据类型</span><br><span class="line">rostopic hz topic_name      # 查看话题数据频率</span><br><span class="line">rostopic echo topic_name    # 打印数据信息</span><br><span class="line">rostopic pub -r 10 topic_name data_type data    # 发布数据</span><br><span class="line"></span><br><span class="line"># 服务相关</span><br><span class="line">rossrv show srv_type        # 查看服务类型</span><br><span class="line">rosservice list             # 查看服务名称</span><br><span class="line">rosservice type srv_name    # 查看服务数据类型    </span><br><span class="line">rosservice call srv_name srv-args  # 命令行请求服务</span><br><span class="line"></span><br><span class="line"># rqt相关</span><br><span class="line">rqt_graph                   # 显示节点话题服务关系</span><br><span class="line">rqt_plot                    # 打印数据</span><br><span class="line"></span><br><span class="line"># tf相关</span><br><span class="line">rosrun tf tf_echo /frame1 /frame2   # 打印frame2相对frame1的变换</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：通讯和回调函数</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2021-07-18T08:43:45.000Z</published>
    <updated>2021-07-22T01:03:06.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><p>ROS将每个进程看做一个节点，使用节点管理器进行统一管理，并提供一套响应的消息传递机制。在ROS中，所有的消息通信都必须使用节点管理器。ROS的特殊性主要体现在消息通讯层，而不是更深的层次。点对点的连接和配置通过XMLRPC机制实现；节点间的数据流通过网络套接字实现，数据流在ROS中被称为消息，模块间的消息传递采用简单的、语言无关的接口定义描述。</p><p>ROS的底层的通信是通过HTTP完成的，因此ROS内核本质上是有一个HTTP服务器，它的地址一般是 <code>http://localhost:11311/</code>，即本地的11311端口，当需要连接到另一台计算机上运行的ROS时，只要连上该机的11311端口即可。</p><p>ROS提供多种类型的通讯机制，包括基于主题的异步数据流通信、基于服务的同步RPC（远程过程调用）通信以及基于参数服务的数据传递，支持实现不同需求的网络连接。</p><h4 id="基于主题的异步数据流通信"><a href="#基于主题的异步数据流通信" class="headerlink" title="基于主题的异步数据流通信"></a>基于主题的异步数据流通信</h4><p>ROS中最主要的通信方式，它实现了节点间多对多的连接，并且采用单向数据流传输数据。通过主题可以实现发布者和订阅者之间的解耦。底层依赖于XMLRPC和TCP/UDP。步骤如下：</p><ol><li>talker注册（XMLRPC）</li><li>listener注册（XMLRPC）</li><li>ros master信息匹配，并将结果返回给listener（XMLRPC）</li><li>listener请求talker（RPC地址请求）</li><li>talker确认连接请求（RPC回复，结果中包含talker的TCP地址）</li><li>listener与talker建立网络连接（TCP）</li><li>talker向listener发布数据（TCP）</li></ol><p>步骤1-5，使用的都是XMLRPC通信，其中步骤4和5，talker和listener会协商共同支持的协议（TCPROS或UDPROS），最后6-7才是真正的TCP或UDP通讯。</p><p><strong>XMLRPC</strong>：ROS节点之间建立连接过程及其与master之间通信均使用XMLRPC（基于XML的远程过程调用），这些远程过程调用采用HTTP传输协议，XML作为传输数据的编码格式。XML的文本属性使得它独立于传输层的编码形式，直接封装在HTTP中传输。远程过程调用的主要作用是负责节点对计算图级中的信息进行获取、更改及一些全局变量的设置，不直接支持数据的流传输。</p><p><strong>TCPROS和UDPROS</strong>：ROS主题通讯支持TCPROS和UDPROS两种通信协议，TCPROS采用标准的TCP/IP套接字，这是ROS默认的传输方式；UDPROS采用标准的UDP传输方式，它是一种低延时、高效率的传输方式，但可能产生数据丢失，所以它比较适用于远程操作任务。</p><h4 id="基于服务的同步RPC通信"><a href="#基于服务的同步RPC通信" class="headerlink" title="基于服务的同步RPC通信"></a>基于服务的同步RPC通信</h4><p>可以实现一对一的连接，采用请求应答的模型。步骤如下：</p><ol><li>talker注册（XMLRPC）</li><li>listener注册（XMLRPC）</li><li>ros master信息匹配，并将结果返回给listener（XMLRPC）</li><li>listener与talker建立网络连接（TCP）</li><li>talker向listener发布数据（TCP）</li></ol><p>可以看到，相比基于主题的异步数据流通信，该过程少了双方协商协议的过程，因为同步RPC通讯只支持TCPROS，客户端不需要通过XMLRPC与服务端协商共同支持的协议。</p><h4 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h4><p>参数服务器是一个可以通过网络访问的多元共享的参数字典，节点在运行时可以在参数服务器上存储或获取参数。参数服务器运行在节点管理器上，它的应用程序编程接口通过XMLRPC库进行访问。可以理解成ROS中的全局变量，只需要XMLRPC通讯，不用TCP，操作如下：</p><ol><li>talker设置参数</li><li>listener查询参数</li><li>master将查询结果返回给listener</li></ol><h4 id="动作action通讯"><a href="#动作action通讯" class="headerlink" title="动作action通讯"></a>动作action通讯</h4><p>带有响应机制的服务。相比于服务的阻塞特性，动作可以在服务端任务执行的过程中，反馈给客户端任务执行的状态，便于客户端查看进度并根据反馈结果作出合理响应。</p><h4 id="优缺点和注意事项"><a href="#优缺点和注意事项" class="headerlink" title="优缺点和注意事项"></a>优缺点和注意事项</h4><p>整体来讲，topic适合数据传输，service适合逻辑处理，action用在需要监视的场景，如实际机器人的轨迹执行。一般使用时都不会有问题，毕竟ROS还是一个很好的工具。但是如果数据量比较大或者回调函数运行时间很长，延时一般就不能忽略，此时就涉及到通讯中的回调函数的处理。</p><h3 id="回调函数和多线程"><a href="#回调函数和多线程" class="headerlink" title="回调函数和多线程"></a><a href="https://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning">回调函数和多线程</a></h3><p>在基于服务的通信中，客户端和服务端的连接每次都会经历一个查找和连接的过程，而且连接仅在此次服务调用期间有效，在调用返回后将被关闭。服务端回调函数每次只处理客户端发送的数据，并不需要维持一个回调函数队列，而且服务端和客户端的api中并没有回调函数队列长度参数。</p><p>但是在基于主题的异步数据流通讯中，订阅者无法确定消息的到达时间，所以利用回调函数，把响应收到消息事件的代码放到回调函数里。通过轮转函数实现回调函数的调用，从而实现消息处理。</p><p>ROS提供了三种形式的回调函数队列，分别是：</p><ol><li>每个订阅者的回调函数队列</li><li>每个NodeHandle的回调函数队列</li><li>全局回调函数队列，即节点的回调函数队列</li></ol><p>其中全局回调函数队列在创建节点时自动创建，前两种需要手动创建。当消息到达时，先查看订阅者回调队列，在查看NodeHandle回调队列，最后才查看全局回调队列。</p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>ros::spin()会导致用户编写的所有回调函数都被调用，并且一旦被调用，将不会返回，除非被关闭。使用ros::spin时，一般在初始化时，都设置好了所有消息的回调函数，并且不需要其他辅助程序运行。</p><p>ros::spinOnce调用后会及时返回，并且还可以继续执行之后的程序。它会在某个时间段内及时调用<strong>所有的回调函数</strong>。一般还需要其他辅助程序的执行，如定时任务，数据处理，用户界面等。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>ros::MulitiThreadSpinner，阻塞执行轮转，与ros::spin类似，执行后无需返回，直到节点被关闭。</p><p>ros::AsyncSpinner: 没有使用阻塞形式，而是包含了start和stop调用，这样编程人员可以随时打开或者停止在回调函数队列上的轮转，实际使用中，这个更有用。</p>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-17T10:46:14.000Z</published>
    <updated>2021-07-18T14:52:24.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么选择Markdown"><a href="#为什么选择Markdown" class="headerlink" title="为什么选择Markdown"></a>为什么选择Markdown</h3><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>相比于印象笔记，有道云笔记和Word，Markdown的功能可以说是“大打折扣”，但是正式因为这种简介的语言格式，让我们能够更加回归内容本身，而不是去关注字体，颜色，排版等琐碎的细节。同时Markdown还有一个好处是很多网站都支持Markdown预览，非常方便。</p><p>Markdown的编辑器比较多，选择自己喜欢的即可，在这里我选择使用VSCode+Markdown插件，当然Typora也是非常好用的编辑器。不过还是刚刚讲的，使用Markdown是回归内容本身，选择自己用着顺手的编辑器即可。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>语法主要包含以下几个方面：</p><ol><li><strong>标题</strong>：使用多个#表示不同的标题级别；</li><li><strong>列表</strong>：<ul><li>无序列表：使用-+*表示；</li><li>有序列表：使用1，2，3表示；</li><li>列表分级：上下级之间用三个空格；</li></ul></li><li><strong>字体</strong>：语法如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>结果如下：<br> <em>斜体</em><br> <strong>粗体</strong><br> <em><strong>斜体加粗</strong></em><br> <del>删除线</del></li><li><strong>超链接</strong>：形式为 <code>[超链接名](超链接地址 &quot;超链接title&quot;)</code>，如<code>[个人博客]（https://zhanghengsjtu.github.io/）</code></li><li><strong>代码</strong><ul><li>单行代码：左右各一个反引号`</li><li>代码块：左右各三个反引号`，且两边的三个反引号独占一行</li></ul></li><li><strong>图片和图床</strong>：基础语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图注](图片地址 &#x27;&#x27;悬浮标题&#x27;&#x27;)</span><br><span class="line">图注就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">悬浮标题是图片的标题，当鼠标移到图片上时显示的内容。悬浮标题可加可不加</span><br></pre></td></tr></table></figure>比如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![NBA全明星](https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210717215222.png &quot;NBA全明星&quot;)</span><br></pre></td></tr></table></figure>效果如下<br><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210717215222.png" alt="NBA全明星" title="NBA全明星"><br>需要注意的是，为了保证多平台统一，图片存储时需要使用图床，提供统一的外部链接，推荐一个简单免费的图床工具。<br><strong>GitHub+Picgo搭建图床主要步骤如下：</strong><ul><li>建立GitHub图片仓库</li><li>创建并获取token</li><li>下载Picgo客户端</li><li>配置客户端</li></ul></li><li><strong>分割线</strong>：三个或者三个以上的-*都可以</li><li><strong>引用</strong>：在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</li><li><strong>表格</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure> 效果如下：<table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，我的个人博客和对Markdown语法的了解初步完成了。Markdown语法比较简单，唯一比较麻烦一些的可能就是图床的制作，相信只要大家耐心一些，肯定能够完成的。下一篇记录一下Hexo+GitHub搭建个人博客的过程。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a></li><li><a href="https://zhuanlan.zhihu.com/p/69210764">https://zhuanlan.zhihu.com/p/69210764</a></li><li><a href="https://www.jianshu.com/p/ea1eb11db63f">https://www.jianshu.com/p/ea1eb11db63f</a></li><li><a href="https://www.cnblogs.com/ly-2019/p/11828790.html">https://www.cnblogs.com/ly-2019/p/11828790.html</a></li><li><a href="https://blog.csdn.net/yefcion/article/details/88412025">https://blog.csdn.net/yefcion/article/details/88412025</a></li></ol>]]></content>
    
    
    <summary type="html">Markdown语法</summary>
    
    
    
    <category term="Markdown" scheme="http://zhanghengsjtu.github.io/categories/Markdown/"/>
    
    
    <category term="Markdown" scheme="http://zhanghengsjtu.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客记录</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/17/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/17/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-07-16T17:27:44.000Z</published>
    <updated>2021-07-18T14:50:14.166Z</updated>
    
    <content type="html"><![CDATA[<p>搭建博客的基本思路是先在本地创建，再部署到远端。首先本地创建时，使用Node.js + Hexo。然后远端部署时，这里使用GitHub。最后再利用比较流行的主题Next对个人博客进行美化，便于自己使用。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Hexo依赖于Node.js，下载地址为<a href="https://nodejs.org/en/download/">Download | Node.js</a>，不过win10默认已经安装了，可以先在命令行输入： node -V和 npm -V，如果已经安装成功，则该步骤可以跳过。node和npm就是安装Hexo的基础环境。</p><h3 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h3><ol><li><p>在D盘创建blog文件夹，然后在该文件夹下面运行：<code>npm install -g hexo-cli </code>即完成了Hexo的安装；</p></li><li><p>在D:\blog下面运行：<code>hexo init blog</code>，完成本地博客的初始化；</p></li><li><p>运行以下命令，并在浏览器输入<code>localhost:4000</code>即可看到最简单的博客</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g    # 生成博客</span><br><span class="line">hexo s    # 在服务端显示</span><br></pre></td></tr></table></figure></li><li><p>到此为止，本地博客最简单的版本就算搭建完成了，此时会在blog文件下面生成一系列文件，主要文件有以下几个：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blog/_config.yml            # 站点配置文件，和后面同名的主题配置文件区分</span><br><span class="line">blog/source/_posts/*.md     # 生成博客的Markdown文件</span><br><span class="line">blog/themes                 # 主题文件夹，后面会介绍，可以更换并配置主题</span><br></pre></td></tr></table></figure></li><li><p>另外，hexo常见的操作如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级</span><br><span class="line">hexo init #初始化博客</span><br><span class="line"># 上述命令基本上一次性使用</span><br><span class="line"># 下面四条最常用</span><br><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure></li></ol><h3 id="Hexo-Github线上运行"><a href="#Hexo-Github线上运行" class="headerlink" title="Hexo+Github线上运行"></a>Hexo+Github线上运行</h3><p>我们搭建博客的目的肯定不是为了只在本地运行，所以需要通过一定的技术手段将博客上传到远端。具体操作时，可以花钱购买域名，也可以使用免费的版本，这里我使用了常见的GitHub作为远端服务器。<br>在这里多说一句，GitHub在国内有时候访问速度很不理想，比如我们实验室，平时下载东西的速度能到30Mb/s，但是访问GitHub有时候就很慢，所以推荐大家购买一个靠谱的vpn并且对GitHub的访问进行合理配置，科学上网。我经常使用的vpn是<a href="https://www.myunlu.com/signin">myunlu</a>，整体使用下来还是很稳定的，我的邀请码是 5A9334B8EA51BAC53A2F8561FB156427。最后在命令行配置GitHub代理即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>接下来就是正式的操作：</p><ol><li><p><strong>创建GitHub仓库</strong>，仓库名一定是<strong>username.github.io</strong></p></li><li><p><strong>安装git</strong>：win下直接下载客户端就行，其他系统同理，安装完成之后，在git bash中执行以下命令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">2. git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br><span class="line">3. ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br><span class="line">4. 复制生成的id_rsa.pub中的密匙，然后到GitHub-&gt;Setting-&gt;new SSH Key中配置</span><br><span class="line">5. ssh git@github.com   # Hi, ***! You&#x27;ve successfully authenticated, but*** 说明成功了</span><br></pre></td></tr></table></figure><p> 上面的一通操作只要知道其目的就行，实质就是通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p></li><li><p><strong>安装git和Hexo联合部署工具</strong>：这个可以理解成GitHub对hexo的一个插件，这样使用简单的hexo命令，就可以完成GitHub部署了，该插件的安装命令为： <code>npm install hexo-deployer-git --save</code></p></li><li><p><strong>修改站点配置文件blog/_config.yam</strong></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https://github.com/[yourusername]/[yourusername].github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li><li><p><strong>部署到远端</strong>：使用以下命令，即可将本地的博客内容部署到远端。此后，只需要用到下面的几条命令以及<a href="https://zhanghengsjtu.github.io/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/">Markdown语法</a>。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  # 清理</span><br><span class="line">hexo g      # 生成</span><br><span class="line">hexo s      # 本地端口4000预览</span><br><span class="line">hexo d      # 推到远端，所以需要上面GitHub关联，和git+hexo联合部署工具</span><br></pre></td></tr></table></figure></li></ol><h3 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h3><p>上述三部分的功能是核心，保证了我们能够搭建最基础的博客。但是默认生成的博客页面大家可能不喜欢，在这里推荐一个比较常见的主题<a href="https://github.com/theme-next/hexo-theme-next">Next</a>。之所以推荐这个主题，和我当初选择Hexo的原因很类似：选择一个成熟好用的框架，这样有问题之后方便交流，毕竟我们的目的不是深入研究网页开发。</p><ol><li><p><strong>下载Next主题</strong>： 在blog目录下，运行命令<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>即可将next主题下载到blog/themes/next下面，其中最重要的文件为blog/themes/next/_config.yam，我们把这个文件叫 <em><strong>主题配置文件</strong></em>，注意和上面的 <em><strong>站点配置文件</strong></em> 的区别。</p></li><li><p><strong>Next主题定制</strong><br>接下来就是根据个人喜好定制Next主题了，在这里推荐<a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/">博客1</a>，<a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">博客2</a>，比较有用的操作主要有以下几个：</p><ul><li>修改基本信息</li><li>修改头像</li><li>修改语言</li><li>菜单设置</li><li>系统评论</li><li>访问量和统计功能</li><li>搜索功能</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过以上几个步骤，就可以搭建一个正常使用的博客了，如果对博客的搭建本身很有兴趣，可以继续查阅相关资料。在我看来，够用就好，把更多的经历放在记录上。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></li><li><a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/">https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/</a></li><li><a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/</a></li></ol>]]></content>
    
    
    <summary type="html">使用Hexo和GitHub构建免费个人博客</summary>
    
    
    
    <category term="Hexo" scheme="http://zhanghengsjtu.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://zhanghengsjtu.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
