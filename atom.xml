<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张恒的博客</title>
  
  
  <link href="http://zhanghengsjtu.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhanghengsjtu.github.io/"/>
  <updated>2021-07-24T07:39:54.834Z</updated>
  <id>http://zhanghengsjtu.github.io/</id>
  
  <author>
    <name>张恒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ROS仿真：ros_control+gazebo</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/22/ROS%E4%BB%BF%E7%9C%9F%EF%BC%9Aros_control+gazebo/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/22/ROS%E4%BB%BF%E7%9C%9F%EF%BC%9Aros_control+gazebo/</id>
    <published>2021-07-22T09:44:14.000Z</published>
    <updated>2021-07-24T07:39:54.834Z</updated>
    
    <content type="html"><![CDATA[<p>用ROS仿真机器人时，无外乎三种硬件：传感器，机械臂和移动机器人，而这些硬件在gazebo中都集成了很好的插件。</p><h2 id="传感器仿真"><a href="#传感器仿真" class="headerlink" title="传感器仿真"></a><a href="http://gazebosim.org/tutorials?tut=ros_gzplugins">传感器仿真</a></h2><p>传感器仿真分为两步，首先在urdf中建立传感器的模型，并固定到机器人上，然后在urdf中指定传感器对应的gazebo插件即可（注意在gazebo中传感器是依附在某一个连杆上的）。</p><p>基本上常见的传感器都可以在gazebo中找到对应的插件，使用的方法也很简单，直接在urdf中配置即可。比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot&gt;</span><br><span class="line">  ... robot description ...</span><br><span class="line">  &lt;link name=&quot;sensor_link&quot;&gt;</span><br><span class="line">    ... link description ...</span><br><span class="line">  &lt;/link&gt;</span><br><span class="line"></span><br><span class="line">  &lt;gazebo reference=&quot;sensor_link&quot;&gt;</span><br><span class="line">    &lt;sensor type=&quot;camera&quot; name=&quot;camera1&quot;&gt;</span><br><span class="line">      ... sensor parameters ...</span><br><span class="line">      &lt;plugin name=&quot;camera_controller&quot; filename=&quot;libgazebo_ros_camera.so&quot;&gt;</span><br><span class="line">        ... plugin parameters ..</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/sensor&gt;</span><br><span class="line">  &lt;/gazebo&gt;</span><br><span class="line"></span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure><p>Gazebo中提供的常见传感器列表如下：</p><ol><li><strong>Camera</strong>： provides ROS interface for simulating cameras such as wge100_camera by publishing the CameraInfo and Image ROS messages as described in sensor_msgs.</li><li><strong>Multicamera</strong>： synchronizes multiple camera’s shutters such that they publish their images together. Typically used for stereo cameras, uses a very similar interface as the plain Camera plugin and currently only supports stereo cameras.</li><li><strong>Depth Camera</strong>: simulates a sensor like a Kinect, which is duplicated in the Kinect plugin.</li><li><strong>GPU Laser</strong>: simulates laser range sensor by broadcasting LaserScan message as described in sensor_msgs.</li><li><strong>Laser</strong>: the non-GPU version of GPU Laser, but essentially uses the same code. </li><li><strong>Block Laser</strong>: provides grid style laser range scanner simulation (e.g. Velodyne).</li><li><strong>Force</strong>: ROS interface for applying Wrench (geometry_msgs) on a body in simulation.</li><li><strong>IMU</strong>: simulates IMU sensor. Measurements are computed by the ROS plugin or by Gazebo.</li></ol><h2 id="机器人仿真"><a href="#机器人仿真" class="headerlink" title="机器人仿真"></a>机器人仿真</h2><h3 id="ROS-CONTROL"><a href="#ROS-CONTROL" class="headerlink" title="ROS_CONTROL"></a>ROS_CONTROL</h3><p>讲机器人仿真之前，先来介绍一下ros_control，因为这个模块和机器人仿真有非常大的关系。</p><p>ros_control是ros为机器人开发者提供的机器人控制中间件，包含一系列控制器接口，传动装置接口，硬件接口，控制器工具等，帮助机器人应用快速落地，提高开发效率。整体框架如下：<img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210724145002.png" alt="ros_control框架"></p><p>可以看到整个ros_control分成了五个部分，每个部分的功能解释如下：</p><ol><li><strong>controller magager控制器管理器</strong>: 作用就是在多个控制器之间切换；</li><li><strong>controller控制器</strong>: ros提供了多个控制器，具体如下<img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210722223610.png" alt="ros_controller"> 如effort_controller/JointPositionController的意思是输入关节位置，输出关节力矩；</li><li><strong>hardware resource interface layer硬件接口</strong>: 这一层是软硬件的分界线，使得软硬件解耦。一方面接收硬件的信息如关节数据，另一方面可以将控制器计算出来的关节控制指令如力矩发送给硬件，目前ros也提供了多个硬件接口，其类型基本与控制器类型相匹配<img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210722223723.png" alt="hardwareInterface"></li><li><strong>hardware interface硬件抽象</strong>: 该层的作用是兼容硬件多样性，同时为上层控制器提供与硬件交互的统一接口，具体功能可以是控制关节约束，力矩转换和状态转换等功能；</li><li><strong>hardware硬件</strong>: 具体的机器人硬件；</li></ol><h3 id="ROS-CONTROL-GAZEBO"><a href="#ROS-CONTROL-GAZEBO" class="headerlink" title="ROS_CONTROL + GAZEBO"></a>ROS_CONTROL + GAZEBO</h3><p>有了上面对ros_control的理解之后，再来看一下其如何与gazebo仿真建立联系，两者之间的关系图如下<img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210724141141.png" alt="gazebo+ros_control"></p><p>可以看到实际硬件和gazebo仿真的差异体现在4和5，即硬件抽象和具体硬件层。在仿真中，gazebo里面的机器人就代表硬件，左边的模块4为ros和gazebo之间沟通的桥梁。在该模块中，通过插件将ros和gazebo连接起来，具体的配置在下面会介绍。</p><h3 id="一般机器人仿真"><a href="#一般机器人仿真" class="headerlink" title="一般机器人仿真"></a>一般机器人仿真</h3><p>机器人仿真的过程也就是配置ros_control+gazebo的过程，具体如下：</p><ul><li><p><strong>设置link标签</strong>：gazebo要求每个实际的link都要有inertial标签，同时link中的visual标签在gazebo中没用，需要单独配置零件的颜色；</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Base Link --&gt;</span><br><span class="line">&lt;link name=&quot;link1&quot;&gt;</span><br><span class="line">    &lt;collision&gt;</span><br><span class="line">        &lt;origin xyz=&quot;0 0 $&#123;height1/2&#125;&quot; rpy=&quot;0 0 0&quot;/&gt;</span><br><span class="line">        &lt;geometry&gt;</span><br><span class="line">            &lt;box size=&quot;$&#123;width&#125; $&#123;width&#125; $&#123;height1&#125;&quot;/&gt;</span><br><span class="line">        &lt;/geometry&gt;</span><br><span class="line">    &lt;/collision&gt;</span><br><span class="line"></span><br><span class="line">    &lt;visual&gt;</span><br><span class="line">        &lt;origin xyz=&quot;0 0 $&#123;height1/2&#125;&quot; rpy=&quot;0 0 0&quot;/&gt;</span><br><span class="line">        &lt;geometry&gt;</span><br><span class="line">            &lt;box size=&quot;$&#123;width&#125; $&#123;width&#125; $&#123;height1&#125;&quot;/&gt;</span><br><span class="line">        &lt;/geometry&gt;</span><br><span class="line">        &lt;material name=&quot;orange&quot;/&gt;</span><br><span class="line">    &lt;/visual&gt;</span><br><span class="line"></span><br><span class="line">    &lt;inertial&gt;</span><br><span class="line">        &lt;origin xyz=&quot;0 0 1&quot; rpy=&quot;0 0 0&quot;/&gt;</span><br><span class="line">        &lt;mass value=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;inertia</span><br><span class="line">            ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot;</span><br><span class="line">            iyy=&quot;1.0&quot; iyz=&quot;0.0&quot;</span><br><span class="line">            izz=&quot;1.0&quot;/&gt;</span><br><span class="line">    &lt;/inertial&gt;</span><br><span class="line">&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">&lt;gazebo reference=&quot;link1&quot;&gt;</span><br><span class="line">    &lt;material&gt;Gazebo/Orange&lt;/material&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>设置joint标签</strong>：设置关节的阻尼等参数，以便进行动力学仿真；同时设置<code>transmission</code>标签，用来表示电机和关节的关系；为每个关节和电机配置<code>hardwareInterface</code>硬件接口，即上图中的模块3；   </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;joint name=&quot;joint2&quot; type=&quot;continuous&quot;&gt;</span><br><span class="line">    &lt;parent link=&quot;base_link&quot;/&gt;</span><br><span class="line">    &lt;child link=&quot;link1&quot;/&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0 $&#123;width&#125; $&#123;height2 - axel_offset*2&#125;&quot; rpy=&quot;0 0 0&quot;/&gt;</span><br><span class="line">    &lt;axis xyz=&quot;0 1 0&quot;/&gt;</span><br><span class="line">    &lt;dynamics damping=&quot;0.7&quot;/&gt;</span><br><span class="line">&lt;/joint&gt;</span><br><span class="line"></span><br><span class="line">&lt;transmission name=&quot;tran1&quot;&gt;</span><br><span class="line">    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</span><br><span class="line">    &lt;joint name=&quot;$link1&quot;&gt;</span><br><span class="line">        &lt;hardwareInterface&gt;PositionJointInterface&lt;/hardwareInterface&gt;</span><br><span class="line">    &lt;/joint&gt;</span><br><span class="line">    &lt;actuator name=&quot;motor1&quot;&gt;</span><br><span class="line">        &lt;hardwareInterface&gt;PositionJointInterface&lt;/hardwareInterface&gt; # indigo之后的版本可以不对电机设置，但必须对joint设置</span><br><span class="line">        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</span><br><span class="line">    &lt;/actuator&gt;</span><br><span class="line">&lt;/transmission&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>加载<code>libgazebo_ros_control.so</code>插件</strong>：即上面的模块4；</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;gazebo_ros_control&quot; filename=&quot;libgazebo_ros_control.so&quot;&gt;</span><br><span class="line">        &lt;robotNamespace&gt;/arm&lt;/robotNamespace&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>加载ros_controller</strong>：最后就是通过配置yaml和launch文件来加载ros_controller，注意加载的控制器需要和<code>hardwareInterface</code>适配，即如果<code>hardwareInterface</code>中配置的是位置控制器，那么ros_controller也要加载位置控制，具体可以参考<a href="http://gazebosim.org/tutorials?tut=ros_control&cat=connect_ros">官方例程</a>。</p></li></ul><p>通过配置不同的控制器，就可以通过ros接口来控制gazebo中的机器人了，比如通过话题控制某个关节，通过action控制整个机器人等。即使都是位置控制，加载的控制器不同，接口也略有差异。</p><p>注意在上述ros_control的配置，我们并没有涉及到机器人具体构型，而重点关注每个关节的运动，为每个关节提供了控制接口。因此上述配置方式理论上对任何构型的机器人都适用。但是对于复杂的机器人，为了能够合理工作，在控制时需要发送合适的控制指令，这个就属于用户自己开发的工作了，和ros_control无关。</p><h3 id="移动机器人仿真"><a href="#移动机器人仿真" class="headerlink" title="移动机器人仿真"></a>移动机器人仿真</h3><p>移动机器人在gazebo中的仿真配置稍微简单一些，整体步骤如下：</p><ul><li>为link设置颜色，inertia标签；</li><li>为joint设置阻尼等参数；</li><li>为移动机器人加载定制的gazebo插件；</li></ul><h4 id="移动机器人和一般机器人仿真的差异"><a href="#移动机器人和一般机器人仿真的差异" class="headerlink" title="移动机器人和一般机器人仿真的差异"></a>移动机器人和一般机器人仿真的差异</h4><p>移动机器人仿真中，并没有配置<code>transmission, hardwareInterface</code>和<code>ros_control</code>，原因解释如下：</p><ol><li>ros_control作为一个通用的框架，通过控制每个关节来控制机器人。比如对于一个差分机器人，通过ros_control的配置，可以驱动每个轮子，进而控制整个机器人。</li><li>对于移动机器人，我们关注如何控制整个机器人，而不是某个轮子。所以相比一般机器人，移动机器人的控制形式较为单一（只有速度控制，而一般机器人有位置，速度，力矩等），而且结构比较有限（差分，四驱，全向等，而一般机器人可以是任意构型），因此就可以对每种构型的移动机器人开发一个特殊的gazebo插件。</li><li>好处是省去了ros_control配置的麻烦，而且在插件中直接可以把移动机器人正逆运动学给解决了。劣势是如果你想控制一个特殊构型的机器人，比如六个轮子，或者想位置控制移动机器人，那么就需要自己开发插件，或者回归ros_control的配置模式。</li></ol><p>接下来就看一下ros中提供的移动机器人仿真插件</p><h4 id="移动机器人gazebo插件"><a href="#移动机器人gazebo插件" class="headerlink" title="移动机器人gazebo插件"></a>移动机器人gazebo插件</h4><p>目前有差分，四驱和全向移动机器人，也可以自己定制</p><ul><li><p><strong>差分移动机器人</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;differential_drive_controller&quot; filename=&quot;libgazebo_ros_diff_drive.so&quot;&gt;</span><br><span class="line">        &lt;rosDebugLevel&gt;Debug&lt;/rosDebugLevel&gt;</span><br><span class="line">        &lt;publishWheelTF&gt;true&lt;/publishWheelTF&gt;</span><br><span class="line">        &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;</span><br><span class="line">        &lt;publishTf&gt;1&lt;/publishTf&gt;</span><br><span class="line">        &lt;publishWheelJointState&gt;true&lt;/publishWheelJointState&gt;</span><br><span class="line">        &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;</span><br><span class="line">        &lt;updateRate&gt;100.0&lt;/updateRate&gt;</span><br><span class="line">        &lt;legacyMode&gt;true&lt;/legacyMode&gt;</span><br><span class="line">        &lt;leftJoint&gt;base_to_wheel_left_joint&lt;/leftJoint&gt;</span><br><span class="line">        &lt;rightJoint&gt;base_to_wheel_right_joint&lt;/rightJoint&gt;</span><br><span class="line">        &lt;wheelSeparation&gt;$&#123;base_link_radius*2&#125;&lt;/wheelSeparation&gt;</span><br><span class="line">        &lt;wheelDiameter&gt;$&#123;2*wheel_radius&#125;&lt;/wheelDiameter&gt;</span><br><span class="line">        &lt;broadcastTF&gt;1&lt;/broadcastTF&gt;</span><br><span class="line">        &lt;wheelTorque&gt;30&lt;/wheelTorque&gt;</span><br><span class="line">        &lt;wheelAcceleration&gt;1.8&lt;/wheelAcceleration&gt;</span><br><span class="line">        &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;</span><br><span class="line">        &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt; </span><br><span class="line">        &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt; </span><br><span class="line">        &lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure><p>  该插件的<a href="https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/src/gazebo_ros_diff_drive.cpp">源码可以看这里</a>，可以看到插件的主要逻辑是：</p><ul><li>配置移动机器人基本参数，如轮子直径，轮距，坐标发布等；</li><li>接收/cmd_vel指令，即控制机器人的速度；</li><li>根据/cmd_vel的信息，更新/odom，然后将里程计信息发布出去；</li><li>根据小车的集合信息，计算出每个轮子的状态，更新/joint_states;</li></ul></li><li><p><strong>四驱移动机器人</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;skid_steer_drive_controller&quot; filename=&quot;libgazebo_ros_skid_steer_drive.so&quot;&gt;</span><br><span class="line">        &lt;updateRate&gt;100.0&lt;/updateRate&gt;</span><br><span class="line">        &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;</span><br><span class="line">        &lt;leftFrontJoint&gt;front_left_wheel_joint&lt;/leftFrontJoint&gt;</span><br><span class="line">        &lt;rightFrontJoint&gt;front_right_wheel_joint&lt;/rightFrontJoint&gt;</span><br><span class="line">        &lt;leftRearJoint&gt;back_left_wheel_joint&lt;/leftRearJoint&gt;</span><br><span class="line">        &lt;rightRearJoint&gt;back_right_wheel_joint&lt;/rightRearJoint&gt;</span><br><span class="line">        &lt;wheelSeparation&gt;0.4&lt;/wheelSeparation&gt;</span><br><span class="line">        &lt;wheelDiameter&gt;0.215&lt;/wheelDiameter&gt;</span><br><span class="line">        &lt;robotBaseFrame&gt;base_link&lt;/robotBaseFrame&gt;</span><br><span class="line">        &lt;torque&gt;20&lt;/torque&gt;</span><br><span class="line">        &lt;topicName&gt;cmd_vel&lt;/topicName&gt;</span><br><span class="line">        &lt;broadcastTF&gt;false&lt;/broadcastTF&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>全向移动机器人</strong>： model plugin that allows arbitrary objects (for instance cubes, spheres and cylinders) to be moved along a horizontal plane using a geometry_msgs/Twist message. The plugin works by imparting a linear velocity (XY) and an angular velocity (Z) to the object every cycle.<br>Here is a full URDF example that demonstrates how to control a floating box inside gazebo using this plugin, using different visual and collision elements. Note: The object needs to have sufficient inertia to prevent undesirable motions - which can occur as a reaction to the supplied velocity. You can try increasing inertia until the object moves as desired. It is also good to have the center of mass close to the ground. （<strong>因为里面没有活动关节，所以不需要对关节设置传动</strong>）</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot name=&quot;test_model&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- root link, on the ground just below the model origin --&gt;</span><br><span class="line">&lt;link name=&quot;base_footprint&quot;&gt;</span><br><span class="line">&lt;visual&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot; /&gt;</span><br><span class="line">    &lt;geometry&gt;</span><br><span class="line">        &lt;box size=&quot;0.001 0.001 0.001&quot; /&gt;</span><br><span class="line">    &lt;/geometry&gt;</span><br><span class="line">    &lt;/visual&gt;</span><br><span class="line">&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">&lt;joint name=&quot;base_link_joint&quot; type=&quot;fixed&quot;&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0.0 0 1.25&quot; rpy=&quot;0 0 0&quot; /&gt;</span><br><span class="line">    &lt;parent link=&quot;base_footprint&quot;/&gt;</span><br><span class="line">    &lt;child link=&quot;base_link&quot; /&gt;</span><br><span class="line">&lt;/joint&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the model --&gt;</span><br><span class="line">&lt;link name=&quot;base_link&quot;&gt;</span><br><span class="line">    &lt;inertial&gt;</span><br><span class="line">    &lt;mass value=&quot;50&quot; /&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0 0 -1.25&quot; /&gt;</span><br><span class="line">    &lt;inertia ixx=&quot;50.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot;</span><br><span class="line">        iyy=&quot;50.0&quot; iyz=&quot;0.0&quot;</span><br><span class="line">        izz=&quot;50.0&quot; /&gt;</span><br><span class="line">    &lt;/inertial&gt;</span><br><span class="line">    &lt;visual&gt;</span><br><span class="line">    &lt;geometry&gt;</span><br><span class="line">        &lt;box size=&quot;0.5 0.5 1.0&quot; /&gt; &lt;!-- does not need to match collision --&gt;</span><br><span class="line">    &lt;/geometry&gt;</span><br><span class="line">    &lt;/visual&gt;</span><br><span class="line">    &lt;collision&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0 0 -1.0&quot; /&gt;</span><br><span class="line">    &lt;geometry&gt;</span><br><span class="line">        &lt;cylinder length=&quot;0.5&quot; radius=&quot;0.25&quot; /&gt;</span><br><span class="line">    &lt;/geometry&gt;</span><br><span class="line">    &lt;/collision&gt;</span><br><span class="line">&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;object_controller&quot; filename=&quot;libgazebo_ros_planar_move.so&quot;&gt;</span><br><span class="line">    &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;</span><br><span class="line">    &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;</span><br><span class="line">    &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;</span><br><span class="line">    &lt;odometryRate&gt;20.0&lt;/odometryRate&gt;</span><br><span class="line">    &lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br><span class="line"></span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>传感器仿真比较简单，先为传感器建立urdf，然后再增加传感器插件和对应的参数即可。</p><p>一般机器人的仿真是建立在对ros_control理解的基础上的，通过对ros_control的配置，可以实现机械臂的仿真。</p><p>移动机器人作为一种特殊的机器人，控制模式较为单一，构型也不复杂，因此ros提供了几种常见的插件来对其控制，相比ros_control的方式，使用定制化的插件配置简单，但劣势是一个插件只对一个固定构型的移动机器人有用。</p>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS仿真：Arbotix控制器</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/22/ROS%E4%BB%BF%E7%9C%9F%EF%BC%9AArbotix%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/22/ROS%E4%BB%BF%E7%9C%9F%EF%BC%9AArbotix%E6%8E%A7%E5%88%B6%E5%99%A8/</id>
    <published>2021-07-22T08:59:25.000Z</published>
    <updated>2021-07-23T09:02:26.220Z</updated>
    
    <content type="html"><![CDATA[<p>ArbotiX是一款控制电机、舵机的控制板，并提供相应的ROS功能包，但是这个功能包不仅可以驱动真实的ArbotiX控制板，还提供了仿真控制器。这样的话，就可以基于ArbotiX+Rviz实现机器人的仿真，当然更加复杂的仿真，还是推荐ros_control+gazebo。</p><p>ArbotiX主要包含以下两个功能包：</p><h4 id="arbotix-python"><a href="#arbotix-python" class="headerlink" title="arbotix_python"></a><a href="http://wiki.ros.org/arbotix_python">arbotix_python</a></h4><p>提供了两个控制器</p><ol><li><p><a href="http://wiki.ros.org/arbotix_python/diff_controller">differ_controller</a>: 差速控制移动机器人，接收<code>/cmd_vel</code>，并更新<code>odom → base_link</code>的坐标关系，典型配置如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controllers: &#123;</span><br><span class="line">    base_controller: &#123;type: diff_controller, base_width: 0.381, ticks_meter: 81807, Kp: 10, Kd: 0, Ki: 0, Ko: 25&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="http://wiki.ros.org/arbotix_python/follow_controller">follow_controller</a>: 使用action交互的控制接口，可以当做moveit中FollowJointTrajectory这个action的server，典型的配置如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">joints: &#123;</span><br><span class="line">joint1: &#123;id: 1, neutral: 205, max_angle: 169.6, min_angle: -169.6, max_speed: 90&#125;,</span><br><span class="line">joint2: &#123;id: 2, max_angle: 134.6, min_angle: -134.6, max_speed: 90&#125;,</span><br><span class="line">joint3: &#123;id: 3, max_angle: 150.1, min_angle: -150.1, max_speed: 90&#125;,</span><br><span class="line">joint4: &#123;id: 4, max_angle: 150.1, min_angle: -150.1, max_speed: 90&#125;,</span><br><span class="line">joint5: &#123;id: 5, max_angle: 150.1, min_angle: -150.1, max_speed: 90&#125;,</span><br><span class="line">joint6: &#123;id: 6, max_angle: 360, min_angle: -360, max_speed: 90&#125;,</span><br><span class="line">finger_joint1: &#123;id: 7, max_speed: 90&#125;,</span><br><span class="line">&#125;</span><br><span class="line">controllers: &#123;</span><br><span class="line">    arm_controller: &#123;type: follow_controller, joints: [joint1, joint2, joint3, joint4, joint5, joint6], action_name: arm_controller/follow_joint_trajectory, onboard: False &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="arbotix-controller"><a href="#arbotix-controller" class="headerlink" title="arbotix_controller"></a><a href="http://wiki.ros.org/arbotix_controllers?distro=noetic">arbotix_controller</a></h4><p>主要用来控制gripper，包含三种控制器，了解即可。</p><ol><li>one_side_gripper_controller.py</li><li>parallel_gripper_controller.py</li><li>parallel_single_servo_controller.py</li></ol>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：命名空间和重映射</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E9%87%8D%E6%98%A0%E5%B0%84/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E9%87%8D%E6%98%A0%E5%B0%84/</id>
    <published>2021-07-21T05:55:25.000Z</published>
    <updated>2021-07-23T07:40:33.378Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><a href="http://wiki.ros.org/Names">命名空间</a></h3><p>ROS中主要有四种命名方式，分为基础，全局，相对和私有。</p><ol><li><strong>全局</strong>：开头有”/“的名称称为全局的命名空间，默认的全局命名空间为”/“，也可以通过以下方式设置；<ol><li>命令参数设置：<code>rosrun turtlesim turtlesim_node __ns:=/my</code></li><li>在launch文件中设置：<code>&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim_node&quot; ns=&quot;sim1&quot;/&gt;</code></li><li>使用环境变量：<code>export ROS_PACKAGE=default-namespace</code></li></ol></li><li><strong>相对</strong>：开头没有”/“的名称。ROS会以全局命名空间+相对名称来对其解析。</li><li><strong>基础</strong>：用来描述资源自身，可以当做相对名称的一个子类；</li><li><strong>私有</strong>：和相对名称一样，私有名称不能够完全确定它们自身所在的命名空间，<strong>和相对名称的区别是　私有名称使用的不是默认命名空间，而是用它们的节点名称作为命名空间</strong>。每个节点内部都有一些资源，这些资源只与本节点相关，不会与其他节点打交道，这时候为了安全我们使用私有名称。</li></ol><p><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210722092411.png" alt="ROS命名空间"></p><p>可以看到节点名本身<code>“node_name”</code>只在私有名称中有效。这个<code>“node_name”</code>就是<code>ros::init(argc,argv,“node_name”)</code>中的<code>node_name</code>，可以通过launch文件覆盖。</p><h3 id="命名映射"><a href="#命名映射" class="headerlink" title="命名映射"></a><a href="http://wiki.ros.org/Remapping%20Arguments">命名映射</a></h3><p>命名映射的基本语法是： <code>name:=new_name</code>。同样的，重映射的规则与名称的全局和相对特性有关系。规则参考如下：<br><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210718223225.png" alt="ros命名映射"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://blog.csdn.net/jrc_january/article/details/76587630">https://blog.csdn.net/jrc_january/article/details/76587630</a></li><li><a href="http://wiki.ros.org/Names">http://wiki.ros.org/Names</a></li><li><a href="http://wiki.ros.org/Remapping%20Arguments">http://wiki.ros.org/Remapping%20Arguments</a></li></ol>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：catkin编译系统</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Acatkin%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Acatkin%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-21T05:52:06.000Z</published>
    <updated>2021-07-22T01:09:20.954Z</updated>
    
    <content type="html"><![CDATA[<p>ROS使用catkin来管理包，它是对CMake的扩展。一个catkin软件包必须要有package.xml和CMakeLists.txt两个文件，前者包括了包的描述和依赖信息，后者是构建包的cmake文件。实际工作中，catkin工具会调用CMakeLists.txt，而生成makefile等文件。</p><h4 id="package-xml基本结构"><a href="#package-xml基本结构" class="headerlink" title="package.xml基本结构"></a><a href="http://wiki.ros.org/catkin/package.xml">package.xml基本结构</a></h4><p>一个典型的package.xml文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;package format=&quot;2&quot;&gt;</span><br><span class="line">  &lt;name&gt;your_package&lt;/name&gt;</span><br><span class="line">  &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">  &lt;description&gt;</span><br><span class="line">    This package adds extra features to rosawesome.</span><br><span class="line">  &lt;/description&gt;</span><br><span class="line">  &lt;maintainer email=&quot;you@example.com&quot;&gt;Your Name&lt;/maintainer&gt;</span><br><span class="line">  &lt;license&gt;BSD&lt;/license&gt;</span><br><span class="line">  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line">  &lt;depend&gt;roscpp&lt;/depend&gt;</span><br><span class="line">  &lt;build_depend&gt;angles&lt;/build_depend&gt;</span><br><span class="line">  &lt;build_export_depend&gt;angles&lt;/build_export_depend&gt;</span><br><span class="line">  &lt;exec_depend&gt;openni_launch&lt;/exec_depend&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure><p>几个重要的标签，解释如下：</p><ol><li><code>buildtool_depend</code>: 编译工具，默认<code>catkin</code>，一般不用修改。</li><li><code>depend</code>：指定编译时的依赖项，包含<code>build_depend</code>，<code>build_export_depend</code>和<code>exec_depend</code>。</li><li><code>build_depend</code>: 指定编译功能包需要的依赖，例如<code>angle</code>包提供了C++头文件和编译文件。</li><li><code>build_export_depend</code>: 指定对功能包构建库需要的依赖，例如本功能包导出的头文件依赖了<code>&lt;angles/angles.h&gt;</code>，那么第三方包使用本包导出的头文件时，仍然需要<code>&lt;build_depend&gt;angles&lt;/build_depend&gt;</code>。</li><li><code>exec_depend</code>: 指定运行该功能包需要的依赖。</li><li><strong>建议</strong>：简单情况直接使用<code>depend</code>标签即可（一个顶仨），也不容易出错；如果是依赖的系统项，可以根据<a href="https://docs.ros.org/en/kinetic/api/catkin/html/howto/format2/index.html">官方建议</a>谨慎选择。</li></ol><h4 id="CMakeLists-txt的基本结构"><a href="#CMakeLists-txt的基本结构" class="headerlink" title="CMakeLists.txt的基本结构"></a><a href="http://wiki.ros.org/catkin/CMakeLists.txt">CMakeLists.txt的基本结构</a></h4><p>CMake是不知道package.xml中的依赖关系的，但是catkin知道，因此在CMakeLists.txt中需要对catkin合理配置，便于处理包的依赖关系。<br>CMakeLists.txt基本结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.3)</span><br><span class="line">project(robot_brain)</span><br><span class="line"># Get the information about this package&#x27;s buildtime dependencies</span><br><span class="line">find_package(catkin REQUIRED</span><br><span class="line">  COMPONENTS message_generation std_msgs sensor_msgs)</span><br><span class="line"></span><br><span class="line"># Declare the message files to be built</span><br><span class="line">add_message_files(FILES</span><br><span class="line">  MyMessage.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Declare the service files to be built</span><br><span class="line">add_service_files(FILES</span><br><span class="line">  MyService.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Actually generate the language-specific message and service files</span><br><span class="line">generate_messages(DEPENDENCIES std_msgs sensor_msgs)</span><br><span class="line"></span><br><span class="line"># Declare that this catkin package&#x27;s runtime dependencies</span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS message_runtime std_msgs sensor_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_executable(message_program src/main.cpp)</span><br><span class="line">add_dependencies(message_program $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS)</span><br><span class="line">target_link_libraries(message_program $&#123;catkin_LIBRARIES&#125; other_lib)</span><br></pre></td></tr></table></figure><p>重要的模块解释如下：</p><ol><li><code>find_package</code>: cmake宏，指定依赖的其他pacakge，实际是生成了一些环境变量，如NAME_FOUND，NAME_INCLUDE_DIRS, NAME_LIBRARYIS，此处catkin是必备依赖 其余的syd_msgs…为组件，这个里面的包在package.xml中一定要有<code>build_depend</code>标签。</li><li><code>catkin_package</code>：catkin宏，生成当前package的cmake配置，供依赖本包的其他软件包调用，同时这个命令必须在add_library()或者add_executable()之前调用；注意这个里面的包在package.xml一定要有<code>build_export_depend</code>标签。</li><li>其余为CMake自身语法，具体可以参考<a href="https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf">CMake学习资料</a>。</li></ol><h4 id="创建msg的注意事项"><a href="#创建msg的注意事项" class="headerlink" title="创建msg的注意事项"></a>创建msg的注意事项</h4><ul><li>在package.xml中<ol><li><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</code></li><li><code>&lt;build_export_depend&gt;message_runtime&lt;/build_export_depend&gt;</code></li><li><code>&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code></li></ol></li><li>在CMakeLists.txt中<ol><li>添加<code>find_package(messaga_generation)</code>，确保可以生成msg文件；</li><li>添加<code>catkin_package(message_runtime)</code>：确保生成的msgs文件可以被外部使用；</li><li>添加<code>add_message_file</code>，添加具体的文件名；</li><li>添加<code>generate_message</code>中的依赖包，如依赖<code>std_msgs</code></li></ol></li></ul>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：launch文件</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Alaunch%E6%96%87%E4%BB%B6/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Alaunch%E6%96%87%E4%BB%B6/</id>
    <published>2021-07-18T09:39:58.000Z</published>
    <updated>2021-07-23T08:47:13.599Z</updated>
    
    <content type="html"><![CDATA[<p>roslaunch的主要作用时启动多个节点，同时在参数服务器上设置参数。使用roslaunch时，会自动启动roscore。</p><h3 id="常见语法"><a href="#常见语法" class="headerlink" title="常见语法"></a>常见语法</h3><ol><li><code>$(find pkg)</code>: 获得包的相对路径；</li><li><code>$(arg foo)</code>: 计算<code>foo</code>的值，arg可以理解成launch文件的内部变量，args是node中传递给节点的参数；</li><li><code>if</code>和<code>unless</code>：所有标签都支持<code>if</code>和<code>unless</code>标签，用来作为条件判断；</li></ol><h3 id="launch标签"><a href="#launch标签" class="headerlink" title="launch标签"></a>launch标签</h3><ol><li><p><code>launch</code>: 最大的标签，唯一的作用是作为launch容器，包含其他标签；</p></li><li><p><code>node</code>: 启动节点的标签。launch文件不能保证里面指定的节点的启动顺序，这个是故意设计的，因为在外部无法知道一个节点何时完全初始化了，所以在写节点的时候，要充分考虑节点的启动顺序带来的安全性问题。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node name=&quot;listener1&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; args=&quot;--test&quot; respawn=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>include</code>：加入另一个launch文件；</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include file=&quot;$(find ur_description)/launch/ur5_bringup.launch&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>remap</code>：参数重映射，可以参考<a href="https://zhanghengsjtu.github.io/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E9%87%8D%E6%98%A0%E5%B0%84/">重映射博客</a>;</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;remap from=&quot;/different_topic&quot; to=&quot;/needed_topic&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>param</code>: 设置参数服务器上的参数，可以使用<code>value, textfile, binfile, command</code>命令加载具体参数。如果该标签放在<code>node</code>下面，将被当做私有参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;10.0&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>rosparam</code>: 将yaml文件设置为参数为参数服务器上的参数，同样的，如果该标签出现在<code>node</code>里面，将作为私有参数；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rosparam command=&quot;load&quot; file=&quot;$(find ur_description)/config/kinematics.yaml&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>arg</code>: 作为launch文件的局部变量使用，使得launch文件的扩展性更强。一般利用arg在多个launch文件传递参数，或者为param设置值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># my_file.launch</span><br><span class="line">&lt;include file=&quot;included.launch&quot;&gt;</span><br><span class="line">    &lt;!-- all vars that included.launch requires must be set --&gt;</span><br><span class="line">    &lt;arg name=&quot;hoge&quot; value=&quot;fuga&quot; /&gt;</span><br><span class="line">&lt;/include&gt;</span><br><span class="line"></span><br><span class="line"># included.launch:</span><br><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;!-- declare arg to be passed in --&gt;</span><br><span class="line">    &lt;arg name=&quot;hoge&quot; /&gt; </span><br><span class="line"></span><br><span class="line">    &lt;!-- read value of arg --&gt;</span><br><span class="line">    &lt;param name=&quot;param&quot; value=&quot;$(arg hoge)&quot;/&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure></li><li><p> <code>group</code>: 将节点归组，方便统一处理，比如设置命名空间等；</p></li><li><p><code>ns</code>：设置命名空间，可以用在<code>node, include,group</code>中。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>launch文件在ros中使用非常频繁，语法琐碎且简单。使用时，建议直接从例程代码中直接修改，同时知道各个标签的含义，便于自己修改和定制化。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://wiki.ros.org/roslaunch">http://wiki.ros.org/roslaunch</a></li><li><a href="http://wiki.ros.org/roslaunch/Architecture">http://wiki.ros.org/roslaunch/Architecture</a></li><li><a href="http://wiki.ros.org/roslaunch/XML">http://wiki.ros.org/roslaunch/XML</a></li></ol>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：常用命令</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-07-18T09:34:44.000Z</published>
    <updated>2021-07-22T07:44:46.666Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">echo $ROS_PACKAGE_PATH  </span><br><span class="line"># 打印ros环境变量，确保/opt/ros/kinetic/share和自己的工作空间在里面</span><br><span class="line"># 同时注意ROS中存在工作空间覆盖的机制，即后设置的路径会放在ROS_PACKAGE_PATH前面</span><br><span class="line"># 实际工作时，系统在ROS_PACKAGE_PATH中从前向后查找对应的包，找到即停止</span><br><span class="line"></span><br><span class="line"># 编译相关</span><br><span class="line">catkin_init_workspace       # 在一个空的文件夹下面初始化一个工作空间</span><br><span class="line">catkin_make                 # 编译对应的工作空间</span><br><span class="line">catkin build -j4            # 编译对应的工作空间，-j4指定用4个核，相比catkin_make，输出信息更丰富</span><br><span class="line">catkin_create_pkg pkg_name dep1 dep2 dep3   # 创建包，并指定依赖</span><br><span class="line"></span><br><span class="line"># 话题相关</span><br><span class="line">rosmsg show msg_type        # 查看消息类型</span><br><span class="line">rostopic list               # 查看话题名称</span><br><span class="line">rostopic type topic_name    # 查看话题数据类型</span><br><span class="line">rostopic hz topic_name      # 查看话题数据频率</span><br><span class="line">rostopic echo topic_name    # 打印数据信息</span><br><span class="line">rostopic pub -r 10 topic_name data_type data    # 发布数据</span><br><span class="line"></span><br><span class="line"># 服务相关</span><br><span class="line">rossrv show srv_type        # 查看服务类型</span><br><span class="line">rosservice list             # 查看服务名称</span><br><span class="line">rosservice type srv_name    # 查看服务数据类型    </span><br><span class="line">rosservice call srv_name srv-args  # 命令行请求服务</span><br><span class="line"></span><br><span class="line"># rqt相关</span><br><span class="line">rqt_graph                   # 显示节点话题服务关系</span><br><span class="line">rqt_plot                    # 打印数据</span><br><span class="line"></span><br><span class="line"># tf相关</span><br><span class="line">tf_monitor /frame1 /frame2  # 查看坐标系之间的关系</span><br><span class="line">tf_echo /frame1 /frame2     # 打印frame2相对frame1的变换</span><br><span class="line">static_transform_publisher x y z yaw pitch roll (或 qx qy qz qw) frame_id child_frame_id period_in_ms   # 静态发布两个坐标系之间的关系</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS基础：通讯和回调函数</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2021-07-18T08:43:45.000Z</published>
    <updated>2021-07-23T07:38:44.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><p>ROS将每个进程看做一个节点，使用节点管理器进行统一管理，并提供一套响应的消息传递机制。在ROS中，所有的消息通信都必须使用节点管理器。ROS的特殊性主要体现在消息通讯层，而不是更深的层次。点对点的连接和配置通过XMLRPC机制实现；节点间的数据流通过网络套接字实现，数据流在ROS中被称为消息，模块间的消息传递采用简单的、语言无关的接口定义描述。</p><p>ROS的底层的通信是通过HTTP完成的，因此ROS内核本质上是有一个HTTP服务器，它的地址一般是 <code>http://localhost:11311/</code>，即本地的11311端口，当需要连接到另一台计算机上运行的ROS时，只要连上该机的11311端口即可。</p><p>ROS提供多种类型的通讯机制，包括基于主题的异步数据流通信、基于服务的同步RPC（远程过程调用）通信以及基于参数服务的数据传递，支持实现不同需求的网络连接。</p><h4 id="基于主题的异步数据流通信"><a href="#基于主题的异步数据流通信" class="headerlink" title="基于主题的异步数据流通信"></a>基于主题的异步数据流通信</h4><p>ROS中最主要的通信方式，它实现了节点间多对多的连接，并且采用单向数据流传输数据。通过主题可以实现发布者和订阅者之间的解耦。底层依赖于XMLRPC和TCP/UDP。步骤如下：</p><ol><li><strong>talker注册</strong>：使用RPC向master注册发布者的信息，包含发布消息的话题名；master将注册信息加入注册列表中；</li><li><strong>listener注册</strong>：使用RPC向master注册订阅者的信息，包含需要订阅的话题名；</li><li><strong>master信息匹配</strong>：根据listener的订阅信息查询注册列表，如果没找到，则等待发布者加入；如果找到了，通过RPC向listener发布talker的RPC地址；</li><li><strong>listener发送连接请求</strong>：listener收到talker的RPC地址之后，尝试通过RPC向talker发送连接请求，传输订阅的话题名，消息类型以及通讯协议（TCP/UDP）</li><li><strong>talker确认连接请求</strong>：talker收到listener发送的连接请求后，继续通过RPC向listener确认连接信息，其中包含自身的TCP地址信息；</li><li><strong>listener与talker建立网络连接</strong>：尝试使用TCP或UDP建立网络连接；</li><li><strong>talker向listener发布数据</strong>：成功建立连接之后，talker开始向listener发布数据；</li></ol><p>步骤1-5，使用的都是XMLRPC通信，其中步骤4和5，talker和listener会协商共同支持的协议（TCPROS或UDPROS），最后6-7才是真正的TCP或UDP通讯。</p><p><strong>XMLRPC</strong>：ROS节点之间建立连接过程及其与master之间通信均使用XMLRPC（基于XML的远程过程调用），这些远程过程调用采用HTTP传输协议，XML作为传输数据的编码格式。XML的文本属性使得它独立于传输层的编码形式，直接封装在HTTP中传输。远程过程调用的主要作用是负责节点对计算图级中的信息进行获取、更改及一些全局变量的设置，不直接支持数据的流传输。</p><p><strong>TCPROS和UDPROS</strong>：ROS主题通讯支持TCPROS和UDPROS两种通信协议，TCPROS采用标准的TCP/IP套接字，这是ROS默认的传输方式；UDPROS采用标准的UDP传输方式，它是一种低延时、高效率的传输方式，但可能产生数据丢失，所以它比较适用于远程操作任务。</p><h4 id="基于服务的同步RPC通信"><a href="#基于服务的同步RPC通信" class="headerlink" title="基于服务的同步RPC通信"></a>基于服务的同步RPC通信</h4><p>可以实现一对一的连接，采用请求应答的模型。步骤如下：</p><ol><li><strong>talker注册</strong>：使用RPC向master注册，包含提供的服务名；master将注册信息加入注册列表中；</li><li><strong>listener注册</strong>：同样通过RPC向master注册，包含需要查找的服务名；</li><li><strong>master信息匹配</strong>：master查询注册列表，没找到，则等待服务加入；<strong>找到的话，则通过RPC向listener发送talker的TCP地址</strong>；</li><li><strong>listener与talker建立网络连接</strong>：listener使用tcp尝试与talker建立网络连接，并发送服务请求数据；</li><li><strong>talker向listener发布数据</strong>：talker收到服务请求和参数之后，开始执行服务功能，执行完成后，向listener发送应答数据。</li></ol><p>可以看到，相比基于主题的异步数据流通信，该过程少了双方协商协议的过程，因为同步RPC通讯只支持TCPROS，客户端不需要通过XMLRPC与服务端协商共同支持的协议。</p><h4 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h4><p>参数服务器是一个可以通过网络访问的多元共享的参数字典，节点在运行时可以在参数服务器上存储或获取参数。参数服务器运行在节点管理器上，它的应用程序编程接口通过XMLRPC库进行访问。可以理解成ROS中的全局变量，只需要XMLRPC通讯，不用TCP，操作如下：</p><ol><li>talker设置参数</li><li>listener查询参数</li><li>master将查询结果返回给listener</li></ol><h4 id="动作action通讯"><a href="#动作action通讯" class="headerlink" title="动作action通讯"></a>动作action通讯</h4><p>带有响应机制的服务。相比于服务的阻塞特性，动作可以在服务端任务执行的过程中，反馈给客户端任务执行的状态，便于客户端查看进度并根据反馈结果作出合理响应。</p><h4 id="优缺点和注意事项"><a href="#优缺点和注意事项" class="headerlink" title="优缺点和注意事项"></a>优缺点和注意事项</h4><p>整体来讲，topic适合数据传输，service适合逻辑处理，action用在需要监视的场景，如实际机器人的轨迹执行。一般使用时都不会有问题，毕竟ROS还是一个很好的工具。但是如果数据量比较大或者回调函数运行时间很长，延时一般就不能忽略，此时就涉及到通讯中的回调函数的处理。</p><h3 id="回调函数和多线程"><a href="#回调函数和多线程" class="headerlink" title="回调函数和多线程"></a><a href="https://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning">回调函数和多线程</a></h3><p>在基于服务的通信中，客户端和服务端的连接每次都会经历一个查找和连接的过程，而且连接仅在此次服务调用期间有效，在调用返回后将被关闭。服务端回调函数每次只处理客户端发送的数据，并不需要维持一个回调函数队列，而且服务端和客户端的api中并没有回调函数队列长度参数。</p><p>但是在基于主题的异步数据流通讯中，订阅者无法确定消息的到达时间，所以利用回调函数，把响应收到消息事件的代码放到回调函数里。通过轮转函数实现回调函数的调用，从而实现消息处理。</p><p>ROS提供了三种形式的回调函数队列，分别是：</p><ol><li>每个订阅者的回调函数队列</li><li>每个NodeHandle的回调函数队列</li><li>全局回调函数队列，即节点的回调函数队列</li></ol><p>其中全局回调函数队列在创建节点时自动创建，前两种需要手动创建。当消息到达时，先查看订阅者回调队列，在查看NodeHandle回调队列，最后才查看全局回调队列。</p><h4 id="单线程轮询"><a href="#单线程轮询" class="headerlink" title="单线程轮询"></a>单线程轮询</h4><p>ros::spin()会导致用户编写的所有回调函数都被调用，并且一旦被调用，将不会返回，除非被关闭。使用ros::spin时，一般在初始化时，都设置好了所有消息的回调函数，并且不需要其他辅助程序运行。</p><p>ros::spinOnce调用后会及时返回，并且还可以继续执行之后的程序。它会在某个时间段内及时调用<strong>所有的回调函数</strong>。一般还需要其他辅助程序的执行，如定时任务，数据处理，用户界面等。</p><h4 id="多线程轮询"><a href="#多线程轮询" class="headerlink" title="多线程轮询"></a>多线程轮询</h4><p>ros::MulitiThreadSpinner，阻塞执行轮转，与ros::spin类似，执行后无需返回，直到节点被关闭。</p><p>ros::AsyncSpinner: 没有使用阻塞形式，而是包含了start和stop调用，这样编程人员可以随时打开或者停止在回调函数队列上的轮转，实际使用中，这个更有用。</p>]]></content>
    
    
    <summary type="html">ROS学习记录</summary>
    
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/categories/ROS/"/>
    
    
    <category term="ROS" scheme="http://zhanghengsjtu.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-17T10:46:14.000Z</published>
    <updated>2021-07-18T14:52:24.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么选择Markdown"><a href="#为什么选择Markdown" class="headerlink" title="为什么选择Markdown"></a>为什么选择Markdown</h3><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>相比于印象笔记，有道云笔记和Word，Markdown的功能可以说是“大打折扣”，但是正式因为这种简介的语言格式，让我们能够更加回归内容本身，而不是去关注字体，颜色，排版等琐碎的细节。同时Markdown还有一个好处是很多网站都支持Markdown预览，非常方便。</p><p>Markdown的编辑器比较多，选择自己喜欢的即可，在这里我选择使用VSCode+Markdown插件，当然Typora也是非常好用的编辑器。不过还是刚刚讲的，使用Markdown是回归内容本身，选择自己用着顺手的编辑器即可。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>语法主要包含以下几个方面：</p><ol><li><strong>标题</strong>：使用多个#表示不同的标题级别；</li><li><strong>列表</strong>：<ul><li>无序列表：使用-+*表示；</li><li>有序列表：使用1，2，3表示；</li><li>列表分级：上下级之间用三个空格；</li></ul></li><li><strong>字体</strong>：语法如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>结果如下：<br> <em>斜体</em><br> <strong>粗体</strong><br> <em><strong>斜体加粗</strong></em><br> <del>删除线</del></li><li><strong>超链接</strong>：形式为 <code>[超链接名](超链接地址 &quot;超链接title&quot;)</code>，如<code>[个人博客]（https://zhanghengsjtu.github.io/）</code></li><li><strong>代码</strong><ul><li>单行代码：左右各一个反引号`</li><li>代码块：左右各三个反引号`，且两边的三个反引号独占一行</li></ul></li><li><strong>图片和图床</strong>：基础语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图注](图片地址 &#x27;&#x27;悬浮标题&#x27;&#x27;)</span><br><span class="line">图注就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">悬浮标题是图片的标题，当鼠标移到图片上时显示的内容。悬浮标题可加可不加</span><br></pre></td></tr></table></figure>比如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![NBA全明星](https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210717215222.png &quot;NBA全明星&quot;)</span><br></pre></td></tr></table></figure>效果如下<br><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210717215222.png" alt="NBA全明星" title="NBA全明星"><br>需要注意的是，为了保证多平台统一，图片存储时需要使用图床，提供统一的外部链接，推荐一个简单免费的图床工具。<br><strong>GitHub+Picgo搭建图床主要步骤如下：</strong><ul><li>建立GitHub图片仓库</li><li>创建并获取token</li><li>下载Picgo客户端</li><li>配置客户端</li></ul></li><li><strong>分割线</strong>：三个或者三个以上的-*都可以</li><li><strong>引用</strong>：在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</li><li><strong>表格</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure> 效果如下：<table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，我的个人博客和对Markdown语法的了解初步完成了。Markdown语法比较简单，唯一比较麻烦一些的可能就是图床的制作，相信只要大家耐心一些，肯定能够完成的。下一篇记录一下Hexo+GitHub搭建个人博客的过程。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a></li><li><a href="https://zhuanlan.zhihu.com/p/69210764">https://zhuanlan.zhihu.com/p/69210764</a></li><li><a href="https://www.jianshu.com/p/ea1eb11db63f">https://www.jianshu.com/p/ea1eb11db63f</a></li><li><a href="https://www.cnblogs.com/ly-2019/p/11828790.html">https://www.cnblogs.com/ly-2019/p/11828790.html</a></li><li><a href="https://blog.csdn.net/yefcion/article/details/88412025">https://blog.csdn.net/yefcion/article/details/88412025</a></li></ol>]]></content>
    
    
    <summary type="html">Markdown语法</summary>
    
    
    
    <category term="Markdown" scheme="http://zhanghengsjtu.github.io/categories/Markdown/"/>
    
    
    <category term="Markdown" scheme="http://zhanghengsjtu.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客记录</title>
    <link href="http://zhanghengsjtu.github.io/2021/07/17/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://zhanghengsjtu.github.io/2021/07/17/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-07-16T17:27:44.000Z</published>
    <updated>2021-07-18T14:50:14.166Z</updated>
    
    <content type="html"><![CDATA[<p>搭建博客的基本思路是先在本地创建，再部署到远端。首先本地创建时，使用Node.js + Hexo。然后远端部署时，这里使用GitHub。最后再利用比较流行的主题Next对个人博客进行美化，便于自己使用。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Hexo依赖于Node.js，下载地址为<a href="https://nodejs.org/en/download/">Download | Node.js</a>，不过win10默认已经安装了，可以先在命令行输入： node -V和 npm -V，如果已经安装成功，则该步骤可以跳过。node和npm就是安装Hexo的基础环境。</p><h3 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h3><ol><li><p>在D盘创建blog文件夹，然后在该文件夹下面运行：<code>npm install -g hexo-cli </code>即完成了Hexo的安装；</p></li><li><p>在D:\blog下面运行：<code>hexo init blog</code>，完成本地博客的初始化；</p></li><li><p>运行以下命令，并在浏览器输入<code>localhost:4000</code>即可看到最简单的博客</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g    # 生成博客</span><br><span class="line">hexo s    # 在服务端显示</span><br></pre></td></tr></table></figure></li><li><p>到此为止，本地博客最简单的版本就算搭建完成了，此时会在blog文件下面生成一系列文件，主要文件有以下几个：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blog/_config.yml            # 站点配置文件，和后面同名的主题配置文件区分</span><br><span class="line">blog/source/_posts/*.md     # 生成博客的Markdown文件</span><br><span class="line">blog/themes                 # 主题文件夹，后面会介绍，可以更换并配置主题</span><br></pre></td></tr></table></figure></li><li><p>另外，hexo常见的操作如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级</span><br><span class="line">hexo init #初始化博客</span><br><span class="line"># 上述命令基本上一次性使用</span><br><span class="line"># 下面四条最常用</span><br><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure></li></ol><h3 id="Hexo-Github线上运行"><a href="#Hexo-Github线上运行" class="headerlink" title="Hexo+Github线上运行"></a>Hexo+Github线上运行</h3><p>我们搭建博客的目的肯定不是为了只在本地运行，所以需要通过一定的技术手段将博客上传到远端。具体操作时，可以花钱购买域名，也可以使用免费的版本，这里我使用了常见的GitHub作为远端服务器。<br>在这里多说一句，GitHub在国内有时候访问速度很不理想，比如我们实验室，平时下载东西的速度能到30Mb/s，但是访问GitHub有时候就很慢，所以推荐大家购买一个靠谱的vpn并且对GitHub的访问进行合理配置，科学上网。我经常使用的vpn是<a href="https://www.myunlu.com/signin">myunlu</a>，整体使用下来还是很稳定的，我的邀请码是 5A9334B8EA51BAC53A2F8561FB156427。最后在命令行配置GitHub代理即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>接下来就是正式的操作：</p><ol><li><p><strong>创建GitHub仓库</strong>，仓库名一定是<strong>username.github.io</strong></p></li><li><p><strong>安装git</strong>：win下直接下载客户端就行，其他系统同理，安装完成之后，在git bash中执行以下命令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">2. git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br><span class="line">3. ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br><span class="line">4. 复制生成的id_rsa.pub中的密匙，然后到GitHub-&gt;Setting-&gt;new SSH Key中配置</span><br><span class="line">5. ssh git@github.com   # Hi, ***! You&#x27;ve successfully authenticated, but*** 说明成功了</span><br></pre></td></tr></table></figure><p> 上面的一通操作只要知道其目的就行，实质就是通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p></li><li><p><strong>安装git和Hexo联合部署工具</strong>：这个可以理解成GitHub对hexo的一个插件，这样使用简单的hexo命令，就可以完成GitHub部署了，该插件的安装命令为： <code>npm install hexo-deployer-git --save</code></p></li><li><p><strong>修改站点配置文件blog/_config.yam</strong></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https://github.com/[yourusername]/[yourusername].github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li><li><p><strong>部署到远端</strong>：使用以下命令，即可将本地的博客内容部署到远端。此后，只需要用到下面的几条命令以及<a href="https://zhanghengsjtu.github.io/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/">Markdown语法</a>。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  # 清理</span><br><span class="line">hexo g      # 生成</span><br><span class="line">hexo s      # 本地端口4000预览</span><br><span class="line">hexo d      # 推到远端，所以需要上面GitHub关联，和git+hexo联合部署工具</span><br></pre></td></tr></table></figure></li></ol><h3 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h3><p>上述三部分的功能是核心，保证了我们能够搭建最基础的博客。但是默认生成的博客页面大家可能不喜欢，在这里推荐一个比较常见的主题<a href="https://github.com/theme-next/hexo-theme-next">Next</a>。之所以推荐这个主题，和我当初选择Hexo的原因很类似：选择一个成熟好用的框架，这样有问题之后方便交流，毕竟我们的目的不是深入研究网页开发。</p><ol><li><p><strong>下载Next主题</strong>： 在blog目录下，运行命令<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>即可将next主题下载到blog/themes/next下面，其中最重要的文件为blog/themes/next/_config.yam，我们把这个文件叫 <em><strong>主题配置文件</strong></em>，注意和上面的 <em><strong>站点配置文件</strong></em> 的区别。</p></li><li><p><strong>Next主题定制</strong><br>接下来就是根据个人喜好定制Next主题了，在这里推荐<a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/">博客1</a>，<a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">博客2</a>，比较有用的操作主要有以下几个：</p><ul><li>修改基本信息</li><li>修改头像</li><li>修改语言</li><li>菜单设置</li><li>系统评论</li><li>访问量和统计功能</li><li>搜索功能</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过以上几个步骤，就可以搭建一个正常使用的博客了，如果对博客的搭建本身很有兴趣，可以继续查阅相关资料。在我看来，够用就好，把更多的经历放在记录上。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></li><li><a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/">https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/</a></li><li><a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/</a></li></ol>]]></content>
    
    
    <summary type="html">使用Hexo和GitHub构建免费个人博客</summary>
    
    
    
    <category term="Hexo" scheme="http://zhanghengsjtu.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://zhanghengsjtu.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
