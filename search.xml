<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+Github搭建个人博客记录</title>
    <url>/2021/07/17/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>搭建博客的基本思路是先在本地创建，再部署到远端。首先本地创建时，使用Node.js + Hexo。然后远端部署时，这里使用GitHub。最后再利用比较流行的主题Next对个人博客进行美化，便于自己使用。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Hexo依赖于Node.js，下载地址为<a href="https://nodejs.org/en/download/">Download | Node.js</a>，不过win10默认已经安装了，可以先在命令行输入： node -V和 npm -V，如果已经安装成功，则该步骤可以跳过。node和npm就是安装Hexo的基础环境。</p>
<h3 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h3><ol>
<li><p>在D盘创建blog文件夹，然后在该文件夹下面运行：<code>npm install -g hexo-cli </code>即完成了Hexo的安装；</p>
</li>
<li><p>在D:\blog下面运行：<code>hexo init blog</code>，完成本地博客的初始化；</p>
</li>
<li><p>运行以下命令，并在浏览器输入<code>localhost:4000</code>即可看到最简单的博客</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g    # 生成博客</span><br><span class="line">hexo s    # 在服务端显示</span><br></pre></td></tr></table></figure></li>
<li><p>到此为止，本地博客最简单的版本就算搭建完成了，此时会在blog文件下面生成一系列文件，主要文件有以下几个：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog/_config.yml            # 站点配置文件，和后面同名的主题配置文件区分</span><br><span class="line">blog/source/_posts/*.md     # 生成博客的Markdown文件</span><br><span class="line">blog/themes                 # 主题文件夹，后面会介绍，可以更换并配置主题</span><br></pre></td></tr></table></figure></li>
<li><p>另外，hexo常见的操作如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级</span><br><span class="line">hexo init #初始化博客</span><br><span class="line"># 上述命令基本上一次性使用</span><br><span class="line"># 下面四条最常用</span><br><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Hexo-Github线上运行"><a href="#Hexo-Github线上运行" class="headerlink" title="Hexo+Github线上运行"></a>Hexo+Github线上运行</h3><p>我们搭建博客的目的肯定不是为了只在本地运行，所以需要通过一定的技术手段将博客上传到远端。具体操作时，可以花钱购买域名，也可以使用免费的版本，这里我使用了常见的GitHub作为远端服务器。<br>在这里多说一句，GitHub在国内有时候访问速度很不理想，比如我们实验室，平时下载东西的速度能到30Mb/s，但是访问GitHub有时候就很慢，所以推荐大家购买一个靠谱的vpn并且对GitHub的访问进行合理配置，科学上网。我经常使用的vpn是<a href="https://www.myunlu.com/signin">myunlu</a>，整体使用下来还是很稳定的，我的邀请码是 5A9334B8EA51BAC53A2F8561FB156427。最后在命令行配置GitHub代理即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<p>接下来就是正式的操作：</p>
<ol>
<li><p><strong>创建GitHub仓库</strong>，仓库名一定是<strong>username.github.io</strong></p>
</li>
<li><p><strong>安装git</strong>：win下直接下载客户端就行，其他系统同理，安装完成之后，在git bash中执行以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">2. git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br><span class="line">3. ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br><span class="line">4. 复制生成的id_rsa.pub中的密匙，然后到GitHub-&gt;Setting-&gt;new SSH Key中配置</span><br><span class="line">5. ssh git@github.com   # Hi, ***! You&#x27;ve successfully authenticated, but*** 说明成功了</span><br></pre></td></tr></table></figure>
<p> 上面的一通操作只要知道其目的就行，实质就是通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p>
</li>
<li><p><strong>安装git和Hexo联合部署工具</strong>：这个可以理解成GitHub对hexo的一个插件，这样使用简单的hexo命令，就可以完成GitHub部署了，该插件的安装命令为： <code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p><strong>修改站点配置文件blog/_config.yam</strong></p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https://github.com/[yourusername]/[yourusername].github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li>
<li><p><strong>部署到远端</strong>：使用以下命令，即可将本地的博客内容部署到远端。此后，只需要用到下面的几条命令以及<a href="https://zhanghengsjtu.github.io/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/">Markdown语法</a>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean  # 清理</span><br><span class="line">hexo g      # 生成</span><br><span class="line">hexo s      # 本地端口4000预览</span><br><span class="line">hexo d      # 推到远端，所以需要上面GitHub关联，和git+hexo联合部署工具</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h3><p>上述三部分的功能是核心，保证了我们能够搭建最基础的博客。但是默认生成的博客页面大家可能不喜欢，在这里推荐一个比较常见的主题<a href="https://github.com/theme-next/hexo-theme-next">Next</a>。之所以推荐这个主题，和我当初选择Hexo的原因很类似：选择一个成熟好用的框架，这样有问题之后方便交流，毕竟我们的目的不是深入研究网页开发。</p>
<ol>
<li><p><strong>下载Next主题</strong>： 在blog目录下，运行命令<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>即可将next主题下载到blog/themes/next下面，其中最重要的文件为blog/themes/next/_config.yam，我们把这个文件叫 <em><strong>主题配置文件</strong></em>，注意和上面的 <em><strong>站点配置文件</strong></em> 的区别。</p>
</li>
<li><p><strong>Next主题定制</strong><br>接下来就是根据个人喜好定制Next主题了，在这里推荐<a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/">博客1</a>，<a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">博客2</a>，比较有用的操作主要有以下几个：</p>
<ul>
<li>修改基本信息</li>
<li>修改头像</li>
<li>修改语言</li>
<li>菜单设置</li>
<li>系统评论</li>
<li>访问量和统计功能</li>
<li>搜索功能</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过以上几个步骤，就可以搭建一个正常使用的博客了，如果对博客的搭建本身很有兴趣，可以继续查阅相关资料。在我看来，够用就好，把更多的经历放在记录上。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></li>
<li><a href="https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/">https://blog.mrzorg.top/Hexo/2020-02-12-hero-next-theme-settings/</a></li>
<li><a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法学习</title>
    <url>/2021/07/17/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="为什么选择Markdown"><a href="#为什么选择Markdown" class="headerlink" title="为什么选择Markdown"></a>为什么选择Markdown</h3><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比于印象笔记，有道云笔记和Word，Markdown的功能可以说是“大打折扣”，但是正式因为这种简介的语言格式，让我们能够更加回归内容本身，而不是去关注字体，颜色，排版等琐碎的细节。同时Markdown还有一个好处是很多网站都支持Markdown预览，非常方便。</p>
<p>Markdown的编辑器比较多，选择自己喜欢的即可，在这里我选择使用VSCode+Markdown插件，当然Typora也是非常好用的编辑器。不过还是刚刚讲的，使用Markdown是回归内容本身，选择自己用着顺手的编辑器即可。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>语法主要包含以下几个方面：</p>
<ol>
<li><strong>标题</strong>：使用多个#表示不同的标题级别；</li>
<li><strong>列表</strong>：<ul>
<li>无序列表：使用-+*表示；</li>
<li>有序列表：使用1，2，3表示；</li>
<li>列表分级：上下级之间用三个空格；</li>
</ul>
</li>
<li><strong>字体</strong>：语法如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
结果如下：<br> <em>斜体</em><br> <strong>粗体</strong><br> <em><strong>斜体加粗</strong></em><br> <del>删除线</del></li>
<li><strong>超链接</strong>：形式为 <code>[超链接名](超链接地址 &quot;超链接title&quot;)</code>，如<code>[个人博客]（https://zhanghengsjtu.github.io/）</code></li>
<li><strong>代码</strong><ul>
<li>单行代码：左右各一个反引号`</li>
<li>代码块：左右各三个反引号`，且两边的三个反引号独占一行</li>
</ul>
</li>
<li><strong>图片和图床</strong>：基础语法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图注](图片地址 &#x27;&#x27;悬浮标题&#x27;&#x27;)</span><br><span class="line">图注就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">悬浮标题是图片的标题，当鼠标移到图片上时显示的内容。悬浮标题可加可不加</span><br></pre></td></tr></table></figure>
比如<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![NBA全明星](https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210717215222.png &quot;NBA全明星&quot;)</span><br></pre></td></tr></table></figure>
效果如下<br><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210717215222.png" alt="NBA全明星" title="NBA全明星"><br>需要注意的是，为了保证多平台统一，图片存储时需要使用图床，提供统一的外部链接，推荐一个简单免费的图床工具。<br><strong>GitHub+Picgo搭建图床主要步骤如下：</strong><ul>
<li>建立GitHub图片仓库</li>
<li>创建并获取token</li>
<li>下载Picgo客户端</li>
<li>配置客户端</li>
</ul>
</li>
<li><strong>分割线</strong>：三个或者三个以上的-*都可以</li>
<li><strong>引用</strong>：在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</li>
<li><strong>表格</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>
 效果如下：<table>
<thead>
<tr>
<th>表头</th>
<th align="center">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
<tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，我的个人博客和对Markdown语法的了解初步完成了。Markdown语法比较简单，唯一比较麻烦一些的可能就是图床的制作，相信只要大家耐心一些，肯定能够完成的。下一篇记录一下Hexo+GitHub搭建个人博客的过程。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/69210764">https://zhuanlan.zhihu.com/p/69210764</a></li>
<li><a href="https://www.jianshu.com/p/ea1eb11db63f">https://www.jianshu.com/p/ea1eb11db63f</a></li>
<li><a href="https://www.cnblogs.com/ly-2019/p/11828790.html">https://www.cnblogs.com/ly-2019/p/11828790.html</a></li>
<li><a href="https://blog.csdn.net/yefcion/article/details/88412025">https://blog.csdn.net/yefcion/article/details/88412025</a></li>
</ol>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS仿真：Arbotix控制器</title>
    <url>/2021/07/22/ROS%E4%BB%BF%E7%9C%9F%EF%BC%9AArbotix%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>ArbotiX是一款控制电机、舵机的控制板，并提供相应的ROS功能包，但是这个功能包不仅可以驱动真实的ArbotiX控制板，还提供了仿真控制器。这样的话，就可以基于ArbotiX+Rviz实现机器人的仿真，当然更加复杂的仿真，还是推荐ros_control+Gazebo。</p>
<p>ArbotiX主要包含以下两个功能包：</p>
<h4 id="arbotix-python"><a href="#arbotix-python" class="headerlink" title="arbotix_python"></a><a href="http://wiki.ros.org/arbotix_python">arbotix_python</a></h4><p>提供了两个控制器</p>
<ol>
<li><p><a href="http://wiki.ros.org/arbotix_python/diff_controller">differ_controller</a>: 差速控制移动机器人，接收<code>/cmd_vel</code>，并更新<code>odom → base_link</code>的坐标关系，典型配置如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">controllers: &#123;</span><br><span class="line">    base_controller: &#123;type: diff_controller, base_width: 0.381, ticks_meter: 81807, Kp: 10, Kd: 0, Ki: 0, Ko: 25&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="http://wiki.ros.org/arbotix_python/follow_controller">follow_controller</a>: 使用action交互的控制接口，可以当做moveit中FollowJointTrajectory这个action的server，典型的配置如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">joints: &#123;</span><br><span class="line">joint1: &#123;id: 1, neutral: 205, max_angle: 169.6, min_angle: -169.6, max_speed: 90&#125;,</span><br><span class="line">joint2: &#123;id: 2, max_angle: 134.6, min_angle: -134.6, max_speed: 90&#125;,</span><br><span class="line">joint3: &#123;id: 3, max_angle: 150.1, min_angle: -150.1, max_speed: 90&#125;,</span><br><span class="line">joint4: &#123;id: 4, max_angle: 150.1, min_angle: -150.1, max_speed: 90&#125;,</span><br><span class="line">joint5: &#123;id: 5, max_angle: 150.1, min_angle: -150.1, max_speed: 90&#125;,</span><br><span class="line">joint6: &#123;id: 6, max_angle: 360, min_angle: -360, max_speed: 90&#125;,</span><br><span class="line">finger_joint1: &#123;id: 7, max_speed: 90&#125;,</span><br><span class="line">&#125;</span><br><span class="line">controllers: &#123;</span><br><span class="line">    arm_controller: &#123;type: follow_controller, joints: [joint1, joint2, joint3, joint4, joint5, joint6], action_name: arm_controller/follow_joint_trajectory, onboard: False &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="arbotix-controller"><a href="#arbotix-controller" class="headerlink" title="arbotix_controller"></a><a href="http://wiki.ros.org/arbotix_controllers?distro=noetic">arbotix_controller</a></h4><p>主要用来控制gripper，包含三种控制器，了解即可。</p>
<ol>
<li>one_side_gripper_controller.py</li>
<li>parallel_gripper_controller.py</li>
<li>parallel_single_servo_controller.py</li>
</ol>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS基础：catkin编译系统</title>
    <url>/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Acatkin%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>ROS使用catkin来管理包，它是对CMake的扩展。一个catkin软件包必须要有package.xml和CMakeLists.txt两个文件，前者包括了包的描述和依赖信息，后者是构建包的cmake文件。实际工作中，catkin工具会调用CMakeLists.txt，而生成makefile等文件。</p>
<h4 id="package-xml基本结构"><a href="#package-xml基本结构" class="headerlink" title="package.xml基本结构"></a><a href="http://wiki.ros.org/catkin/package.xml">package.xml基本结构</a></h4><p>一个典型的package.xml文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;package format=&quot;2&quot;&gt;</span><br><span class="line">  &lt;name&gt;your_package&lt;/name&gt;</span><br><span class="line">  &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">  &lt;description&gt;</span><br><span class="line">    This package adds extra features to rosawesome.</span><br><span class="line">  &lt;/description&gt;</span><br><span class="line">  &lt;maintainer email=&quot;you@example.com&quot;&gt;Your Name&lt;/maintainer&gt;</span><br><span class="line">  &lt;license&gt;BSD&lt;/license&gt;</span><br><span class="line">  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line">  &lt;depend&gt;roscpp&lt;/depend&gt;</span><br><span class="line">  &lt;build_depend&gt;angles&lt;/build_depend&gt;</span><br><span class="line">  &lt;build_export_depend&gt;angles&lt;/build_export_depend&gt;</span><br><span class="line">  &lt;exec_depend&gt;openni_launch&lt;/exec_depend&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure>

<p>几个重要的标签，解释如下：</p>
<ol>
<li><code>buildtool_depend</code>: 编译工具，默认<code>catkin</code>，一般不用修改。</li>
<li><code>depend</code>：指定编译时的依赖项，包含<code>build_depend</code>，<code>build_export_depend</code>和<code>exec_depend</code>。</li>
<li><code>build_depend</code>: 指定编译功能包需要的依赖，例如<code>angle</code>包提供了C++头文件和编译文件。</li>
<li><code>build_export_depend</code>: 指定对功能包构建库需要的依赖，例如本功能包导出的头文件依赖了<code>&lt;angles/angles.h&gt;</code>，那么第三方包使用本包导出的头文件时，仍然需要<code>&lt;build_depend&gt;angles&lt;/build_depend&gt;</code>。</li>
<li><code>exec_depend</code>: 指定运行该功能包需要的依赖。</li>
<li><strong>建议</strong>：简单情况直接使用<code>depend</code>标签即可（一个顶仨），也不容易出错；如果是依赖的系统项，可以根据<a href="https://docs.ros.org/en/kinetic/api/catkin/html/howto/format2/index.html">官方建议</a>谨慎选择。</li>
</ol>
<h4 id="CMakeLists-txt的基本结构"><a href="#CMakeLists-txt的基本结构" class="headerlink" title="CMakeLists.txt的基本结构"></a><a href="http://wiki.ros.org/catkin/CMakeLists.txt">CMakeLists.txt的基本结构</a></h4><p>CMake是不知道package.xml中的依赖关系的，但是catkin知道，因此在CMakeLists.txt中需要对catkin合理配置，便于处理包的依赖关系。<br>CMakeLists.txt基本结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.3)</span><br><span class="line">project(robot_brain)</span><br><span class="line"># Get the information about this package&#x27;s buildtime dependencies</span><br><span class="line">find_package(catkin REQUIRED</span><br><span class="line">  COMPONENTS message_generation std_msgs sensor_msgs)</span><br><span class="line"></span><br><span class="line"># Declare the message files to be built</span><br><span class="line">add_message_files(FILES</span><br><span class="line">  MyMessage.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Declare the service files to be built</span><br><span class="line">add_service_files(FILES</span><br><span class="line">  MyService.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Actually generate the language-specific message and service files</span><br><span class="line">generate_messages(DEPENDENCIES std_msgs sensor_msgs)</span><br><span class="line"></span><br><span class="line"># Declare that this catkin package&#x27;s runtime dependencies</span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS message_runtime std_msgs sensor_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_executable(message_program src/main.cpp)</span><br><span class="line">add_dependencies(message_program $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS)</span><br><span class="line">target_link_libraries(message_program $&#123;catkin_LIBRARIES&#125; other_lib)</span><br></pre></td></tr></table></figure>

<p>重要的模块解释如下：</p>
<ol>
<li><code>find_package</code>: cmake宏，指定依赖的其他pacakge，实际是生成了一些环境变量，如NAME_FOUND，NAME_INCLUDE_DIRS, NAME_LIBRARYIS，此处catkin是必备依赖 其余的syd_msgs…为组件，这个里面的包在package.xml中一定要有<code>build_depend</code>标签。</li>
<li><code>catkin_package</code>：catkin宏，生成当前package的cmake配置，供依赖本包的其他软件包调用，同时这个命令必须在add_library()或者add_executable()之前调用；注意这个里面的包在package.xml一定要有<code>build_export_depend</code>标签。</li>
<li>其余为CMake自身语法，具体可以参考<a href="https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf">CMake学习资料</a>。</li>
</ol>
<h4 id="创建msg的注意事项"><a href="#创建msg的注意事项" class="headerlink" title="创建msg的注意事项"></a>创建msg的注意事项</h4><ul>
<li>在package.xml中<ol>
<li><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</code></li>
<li><code>&lt;build_export_depend&gt;message_runtime&lt;/build_export_depend&gt;</code></li>
<li><code>&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code></li>
</ol>
</li>
<li>在CMakeLists.txt中<ol>
<li>添加<code>find_package(messaga_generation)</code>，确保可以生成msg文件；</li>
<li>添加<code>catkin_package(message_runtime)</code>：确保生成的msgs文件可以被外部使用；</li>
<li>添加<code>add_message_file</code>，添加具体的文件名；</li>
<li>添加<code>generate_message</code>中的依赖包，如依赖<code>std_msgs</code></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS仿真：ros_control+Gazebo</title>
    <url>/2021/07/22/ROS%E4%BB%BF%E7%9C%9F%EF%BC%9Aros-control-Gazebo/</url>
    <content><![CDATA[<p>实际用ROS仿真机器人时，无外乎使用三种硬件：移动机器人，机械臂和传感器，而这些硬件在gazebo中都集成了很好的插件。</p>
<h3 id="传感器仿真"><a href="#传感器仿真" class="headerlink" title="传感器仿真"></a><a href="http://gazebosim.org/tutorials?tut=ros_gzplugins">传感器仿真</a></h3><p>传感器仿真分为两步，首先在urdf中建立传感器的模型，并固定到机器人上，然后在urdf中指定传感器对应的gazebo插件即可。</p>
<p>常见的传感器列表如下：</p>
<ol>
<li><strong>Camera</strong>： provides ROS interface for simulating cameras such as wge100_camera by publishing the CameraInfo and Image ROS messages as described in sensor_msgs.</li>
<li><strong>Multicamera</strong>： synchronizes multiple camera’s shutters such that they publish their images together. Typically used for stereo cameras, uses a very similar interface as the plain Camera plugin and currently only supports stereo cameras.</li>
<li><strong>Depth Camera</strong>: simulates a sensor like a Kinect, which is duplicated in the Kinect plugin.</li>
<li><strong>GPU Laser</strong>: simulates laser range sensor by broadcasting LaserScan message as described in sensor_msgs.</li>
<li><strong>Laser</strong>: the non-GPU version of GPU Laser, but essentially uses the same code. </li>
<li><strong>Block Laser</strong>: provides grid style laser range scanner simulation (e.g. Velodyne).</li>
<li><strong>Force</strong>: ROS interface for applying Wrench (geometry_msgs) on a body in simulation.</li>
<li><strong>IMU</strong>: simulates IMU sensor. Measurements are computed by the ROS plugin or by Gazebo.</li>
</ol>
<p>基本上常见的传感器都可以在gazebo中找到对应的插件，使用的方法也很简单，直接在urdf中配置即可。比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;robot&gt;</span><br><span class="line">  ... robot description ...</span><br><span class="line">  &lt;link name=&quot;sensor_link&quot;&gt;</span><br><span class="line">    ... link description ...</span><br><span class="line">  &lt;/link&gt;</span><br><span class="line"></span><br><span class="line">  &lt;gazebo reference=&quot;sensor_link&quot;&gt;</span><br><span class="line">    &lt;sensor type=&quot;camera&quot; name=&quot;camera1&quot;&gt;</span><br><span class="line">      ... sensor parameters ...</span><br><span class="line">      &lt;plugin name=&quot;camera_controller&quot; filename=&quot;libgazebo_ros_camera.so&quot;&gt;</span><br><span class="line">        ... plugin parameters ..</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/sensor&gt;</span><br><span class="line">  &lt;/gazebo&gt;</span><br><span class="line"></span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure>

<h3 id="机器人仿真"><a href="#机器人仿真" class="headerlink" title="机器人仿真"></a>机器人仿真</h3><p>机器人在Gazebo中的仿真主要分为urdf文件的修改和launch文件中ros_controller的加载。整体步骤如下：</p>
<ul>
<li>为link设置颜色，inertia标签；</li>
<li>为joint设置阻尼，transmission传动接口等；</li>
<li>为机器人加载gazebo插件；</li>
<li>配置<a href="http://wiki.ros.org/ros_control">ros_controller</a>；</li>
</ul>
<p>以上步骤在移动机器人和机械臂的仿真配置中略有差别，移动机器人复杂在<code>为机器人加载gazebo插件</code>，机械臂复杂在<code>transmission传动接口</code>和<code>配置ros_controller</code>。</p>
<h4 id="移动机器人仿真"><a href="#移动机器人仿真" class="headerlink" title="移动机器人仿真"></a>移动机器人仿真</h4><ol>
<li><strong>transmission传动接口</strong>：移动机器人关节的transmission为velocity控制，代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transmission name=&quot;wheel_joint_trans&quot;&gt;</span><br><span class="line">    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</span><br><span class="line">    &lt;joint name=&quot;wheel_joint&quot;&gt;</span><br><span class="line">        &lt;hardwareInterface&gt;VelocityJointInterface&lt;/hardwareInterface&gt;</span><br><span class="line">    &lt;/joint&gt;</span><br><span class="line">    &lt;actuator name=&quot;wheel_joint_motor&quot;&gt;</span><br><span class="line">        &lt;hardwareInterface&gt;VelocityJointInterface&lt;/hardwareInterface&gt; # indigo及之后的版本可以不指定</span><br><span class="line">        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</span><br><span class="line">    &lt;/actuator&gt;</span><br><span class="line">&lt;/transmission&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>gazebo插件</strong>：有差分，四驱和全向移动机器人。</li>
</ol>
<ul>
<li><p><strong>差分移动机器人</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;differential_drive_controller&quot; filename=&quot;libgazebo_ros_diff_drive.so&quot;&gt;</span><br><span class="line">        &lt;rosDebugLevel&gt;Debug&lt;/rosDebugLevel&gt;</span><br><span class="line">        &lt;publishWheelTF&gt;true&lt;/publishWheelTF&gt;</span><br><span class="line">        &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;</span><br><span class="line">        &lt;publishTf&gt;1&lt;/publishTf&gt;</span><br><span class="line">        &lt;publishWheelJointState&gt;true&lt;/publishWheelJointState&gt;</span><br><span class="line">        &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;</span><br><span class="line">        &lt;updateRate&gt;100.0&lt;/updateRate&gt;</span><br><span class="line">        &lt;legacyMode&gt;true&lt;/legacyMode&gt;</span><br><span class="line">        &lt;leftJoint&gt;base_to_wheel_left_joint&lt;/leftJoint&gt;</span><br><span class="line">        &lt;rightJoint&gt;base_to_wheel_right_joint&lt;/rightJoint&gt;</span><br><span class="line">        &lt;wheelSeparation&gt;$&#123;base_link_radius*2&#125;&lt;/wheelSeparation&gt;</span><br><span class="line">        &lt;wheelDiameter&gt;$&#123;2*wheel_radius&#125;&lt;/wheelDiameter&gt;</span><br><span class="line">        &lt;broadcastTF&gt;1&lt;/broadcastTF&gt;</span><br><span class="line">        &lt;wheelTorque&gt;30&lt;/wheelTorque&gt;</span><br><span class="line">        &lt;wheelAcceleration&gt;1.8&lt;/wheelAcceleration&gt;</span><br><span class="line">        &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;</span><br><span class="line">        &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt; </span><br><span class="line">        &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt; </span><br><span class="line">        &lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>四驱移动机器人</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;skid_steer_drive_controller&quot; filename=&quot;libgazebo_ros_skid_steer_drive.so&quot;&gt;</span><br><span class="line">        &lt;updateRate&gt;100.0&lt;/updateRate&gt;</span><br><span class="line">        &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;</span><br><span class="line">        &lt;leftFrontJoint&gt;front_left_wheel_joint&lt;/leftFrontJoint&gt;</span><br><span class="line">        &lt;rightFrontJoint&gt;front_right_wheel_joint&lt;/rightFrontJoint&gt;</span><br><span class="line">        &lt;leftRearJoint&gt;back_left_wheel_joint&lt;/leftRearJoint&gt;</span><br><span class="line">        &lt;rightRearJoint&gt;back_right_wheel_joint&lt;/rightRearJoint&gt;</span><br><span class="line">        &lt;wheelSeparation&gt;0.4&lt;/wheelSeparation&gt;</span><br><span class="line">        &lt;wheelDiameter&gt;0.215&lt;/wheelDiameter&gt;</span><br><span class="line">        &lt;robotBaseFrame&gt;base_link&lt;/robotBaseFrame&gt;</span><br><span class="line">        &lt;torque&gt;20&lt;/torque&gt;</span><br><span class="line">        &lt;topicName&gt;cmd_vel&lt;/topicName&gt;</span><br><span class="line">        &lt;broadcastTF&gt;false&lt;/broadcastTF&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>全向移动机器人</strong>： model plugin that allows arbitrary objects (for instance cubes, spheres and cylinders) to be moved along a horizontal plane using a geometry_msgs/Twist message. The plugin works by imparting a linear velocity (XY) and an angular velocity (Z) to the object every cycle.<br>Here is a full URDF example that demonstrates how to control a floating box inside gazebo using this plugin, using different visual and collision elements. Note: The object needs to have sufficient inertia to prevent undesirable motions - which can occur as a reaction to the supplied velocity. You can try increasing inertia until the object moves as desired. It is also good to have the center of mass close to the ground. （<strong>因为里面没有活动关节，所以不需要对关节设置传动</strong>）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;robot name=&quot;test_model&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- root link, on the ground just below the model origin --&gt;</span><br><span class="line">&lt;link name=&quot;base_footprint&quot;&gt;</span><br><span class="line">&lt;visual&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot; /&gt;</span><br><span class="line">    &lt;geometry&gt;</span><br><span class="line">        &lt;box size=&quot;0.001 0.001 0.001&quot; /&gt;</span><br><span class="line">    &lt;/geometry&gt;</span><br><span class="line">    &lt;/visual&gt;</span><br><span class="line">&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">&lt;joint name=&quot;base_link_joint&quot; type=&quot;fixed&quot;&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0.0 0 1.25&quot; rpy=&quot;0 0 0&quot; /&gt;</span><br><span class="line">    &lt;parent link=&quot;base_footprint&quot;/&gt;</span><br><span class="line">    &lt;child link=&quot;base_link&quot; /&gt;</span><br><span class="line">&lt;/joint&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the model --&gt;</span><br><span class="line">&lt;link name=&quot;base_link&quot;&gt;</span><br><span class="line">    &lt;inertial&gt;</span><br><span class="line">    &lt;mass value=&quot;50&quot; /&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0 0 -1.25&quot; /&gt;</span><br><span class="line">    &lt;inertia ixx=&quot;50.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot;</span><br><span class="line">        iyy=&quot;50.0&quot; iyz=&quot;0.0&quot;</span><br><span class="line">        izz=&quot;50.0&quot; /&gt;</span><br><span class="line">    &lt;/inertial&gt;</span><br><span class="line">    &lt;visual&gt;</span><br><span class="line">    &lt;geometry&gt;</span><br><span class="line">        &lt;box size=&quot;0.5 0.5 1.0&quot; /&gt; &lt;!-- does not need to match collision --&gt;</span><br><span class="line">    &lt;/geometry&gt;</span><br><span class="line">    &lt;/visual&gt;</span><br><span class="line">    &lt;collision&gt;</span><br><span class="line">    &lt;origin xyz=&quot;0 0 -1.0&quot; /&gt;</span><br><span class="line">    &lt;geometry&gt;</span><br><span class="line">        &lt;cylinder length=&quot;0.5&quot; radius=&quot;0.25&quot; /&gt;</span><br><span class="line">    &lt;/geometry&gt;</span><br><span class="line">    &lt;/collision&gt;</span><br><span class="line">&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;object_controller&quot; filename=&quot;libgazebo_ros_planar_move.so&quot;&gt;</span><br><span class="line">    &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;</span><br><span class="line">    &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;</span><br><span class="line">    &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;</span><br><span class="line">    &lt;odometryRate&gt;20.0&lt;/odometryRate&gt;</span><br><span class="line">    &lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br><span class="line"></span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>移动机器人仿真不需要额外加载ros_controller，因为gazebo插件可以直接解析模型（不同的.so就是针对不同类型的移动机器人设置的），直接通过/cmd_vel发送速度指令控制机器人了。</p>
<h4 id="机械臂仿真"><a href="#机械臂仿真" class="headerlink" title="机械臂仿真"></a>机械臂仿真</h4><p>机械臂仿真的流程和移动机器人类似，但是关节的transmission和ros_controller配置略微复杂。</p>
<ol>
<li><p>关节transmission：transmission的类型目前只有SimpleTransmission。hardwareInterface支持的列表如下<img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210722223723.png" alt="hardwareInterface"><br>下面展示了PositionJointInterface的配置方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transmission name=&quot;tran1&quot;&gt;</span><br><span class="line">    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</span><br><span class="line">    &lt;joint name=&quot;$&#123;joint_name&#125;&quot;&gt;</span><br><span class="line">        &lt;hardwareInterface&gt;PositionJointInterface&lt;/hardwareInterface&gt;</span><br><span class="line">    &lt;/joint&gt;</span><br><span class="line">    &lt;actuator name=&quot;motor1&quot;&gt;</span><br><span class="line">        &lt;hardwareInterface&gt;PositionJointInterface&lt;/hardwareInterface&gt;</span><br><span class="line">        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</span><br><span class="line">    &lt;/actuator&gt;</span><br><span class="line">&lt;/transmission&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>gazebo插件：直接加载gazebo_ros_control即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;gazebo&gt;</span><br><span class="line">    &lt;plugin name=&quot;gazebo_ros_control&quot; filename=&quot;libgazebo_ros_control.so&quot;&gt;</span><br><span class="line">        &lt;robotNamespace&gt;/arm&lt;/robotNamespace&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/gazebo&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>ros_controller: 支持的控制器列表如下<img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210722223610.png" alt="ros_controller"> </p>
</li>
</ol>
<p>可以看到hardwareInterface的类别和ros_controller支持的种类相互对应。hardwareInterface主要有以下四种（代表的是输出数据类型）：</p>
<ul>
<li>PositionJointInterface</li>
<li>VelocityJointInterface</li>
<li>EffortJointInterface</li>
<li>JointStateInterface</li>
</ul>
<p>而ros_controller也主要包含四种（代表的仍是输出数据类型）：</p>
<ul>
<li>position_controller: JointPositionController, JointGroupPositionController</li>
<li>velocity_controller: JointVelocityController, JointGroupVelocityController</li>
<li>effort_controller: JointEffortController, JointVelocityController, JointPositionController</li>
<li>joint_state_controller</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>传感器仿真比较简单，先为传感器建立urdf，然后再增加传感器插件和对应的参数即可。</p>
<p>机器人仿真略微麻烦，而且不同的控制器配置的形式也不太一样。整体步骤就是：</p>
<ul>
<li>为link设置颜色，inertia标签；</li>
<li>为joint设置阻尼，transmission传动接口等；</li>
<li>为机器人加载gazebo插件；</li>
<li>配置ros_controller；</li>
</ul>
<p>后面三个的配置形式和机器人相关：</p>
<ul>
<li>移动机器人：目前支持的transmission/hardwareInterface只有VelocityJointInterface；然后gazebo插件一定是libgazebo_ros_diff_drive.so，libgazebo_ros_skid_steer_drive.so或libgazebo_ros_planar_move.so；最后因为插件是为移动机器人定制的，就不需要额外配置ros_controller了，控制功能直接在对应的插件中集成好了，通过/cmd_vel即可控制机器人；</li>
<li>机械臂：因为机械臂形式多样，控制接口也更加复杂，所以在ros中采用了和移动机器人不一样的思路，即简化插件，增加hardwareInterface和ros_controller。所以插件只有libgazebo_ros_control.so；需要根据不同的需求配置hardwareInterface和ros_controller。</li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS基础：launch文件</title>
    <url>/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9Alaunch%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li>记录launch文件学习细节</li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS基础：命名空间和重映射</title>
    <url>/2021/07/21/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E9%87%8D%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><a href="http://wiki.ros.org/Names">命名空间</a></h3><p>主要有四种命名方式，分为基础，全局，相对和私有。</p>
<ol>
<li><strong>全局</strong>：开头有”/“的名称称为全局的命名空间，默认的全局命名空间为”/“，也可以通过以下方式设置；<ol>
<li>命令参数设置：<code>rosrun turtlesim turtlesim_node __ns:=/my</code></li>
<li>在launch文件中设置：<code>&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim_node&quot; ns=&quot;sim1&quot;/&gt;</code></li>
<li>使用环境变量：<code>export ROS_PACKAGE=default-namespace</code></li>
</ol>
</li>
<li><strong>相对</strong>：开头没有”/“的名称。ROS会以全局命名空间+相对名称来对其解析。</li>
<li><strong>基础</strong>：用来描述资源自身，可以当做相对名称的一个子类；</li>
<li><strong>私有</strong>：和相对名称一样，私有名称不能够完全确定它们自身所在的命名空间，<strong>和相对名称的区别是　私有名称使用的不是默认命名空间，而是用它们的节点名称作为命名空间</strong>。每个节点内部都有一些资源，这些资源只与本节点相关，不会与其他节点打交道，这时候为了安全我们使用私有名称。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210722092411.png" alt="ROS命名空间"></p>
<p>可以看到节点名本身<code>“node_name”</code>只在私有名称中有效。这个<code>“node_name”</code>就是<code>ros::init(argc,argv,“node_name”)</code>中的<code>node_name</code>，可以通过launch文件覆盖。</p>
<h3 id="命名映射"><a href="#命名映射" class="headerlink" title="命名映射"></a><a href="http://wiki.ros.org/Remapping%20Arguments">命名映射</a></h3><p>命名映射的基本语法是： <code>name:=new_name</code>。同样的，重映射的规则与名称的全局和相对特性有关系。规则参考如下：<br><img src="https://raw.githubusercontent.com/zhanghengsjtu/figureBed/main/img/20210718223225.png" alt="ros命名映射"></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://blog.csdn.net/jrc_january/article/details/76587630">https://blog.csdn.net/jrc_january/article/details/76587630</a></li>
<li><a href="http://wiki.ros.org/Names">http://wiki.ros.org/Names</a></li>
<li><a href="http://wiki.ros.org/Remapping%20Arguments">http://wiki.ros.org/Remapping%20Arguments</a></li>
</ol>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS基础：常用命令</title>
    <url>/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $ROS_PACKAGE_PATH  </span><br><span class="line"># 打印ros环境变量，确保/opt/ros/kinetic/share和自己的工作空间在里面</span><br><span class="line"># 同时注意ROS中存在工作空间覆盖的机制，即后设置的路径会放在ROS_PACKAGE_PATH前面</span><br><span class="line"># 实际工作时，系统在ROS_PACKAGE_PATH中从前向后查找对应的包，找到即停止</span><br><span class="line"></span><br><span class="line"># 编译相关</span><br><span class="line">catkin_init_workspace       # 在一个空的文件夹下面初始化一个工作空间</span><br><span class="line">catkin_make                 # 编译对应的工作空间</span><br><span class="line">catkin build -j4            # 编译对应的工作空间，-j4指定用4个核，相比catkin_make，输出信息更丰富</span><br><span class="line">catkin_create_pkg pkg_name dep1 dep2 dep3   # 创建包，并指定依赖</span><br><span class="line"></span><br><span class="line"># 话题相关</span><br><span class="line">rosmsg show msg_type        # 查看消息类型</span><br><span class="line">rostopic list               # 查看话题名称</span><br><span class="line">rostopic type topic_name    # 查看话题数据类型</span><br><span class="line">rostopic hz topic_name      # 查看话题数据频率</span><br><span class="line">rostopic echo topic_name    # 打印数据信息</span><br><span class="line">rostopic pub -r 10 topic_name data_type data    # 发布数据</span><br><span class="line"></span><br><span class="line"># 服务相关</span><br><span class="line">rossrv show srv_type        # 查看服务类型</span><br><span class="line">rosservice list             # 查看服务名称</span><br><span class="line">rosservice type srv_name    # 查看服务数据类型    </span><br><span class="line">rosservice call srv_name srv-args  # 命令行请求服务</span><br><span class="line"></span><br><span class="line"># rqt相关</span><br><span class="line">rqt_graph                   # 显示节点话题服务关系</span><br><span class="line">rqt_plot                    # 打印数据</span><br><span class="line"></span><br><span class="line"># tf相关</span><br><span class="line">tf_monitor /frame1 /frame2  # 查看坐标系之间的关系</span><br><span class="line">tf_echo /frame1 /frame2     # 打印frame2相对frame1的变换</span><br><span class="line">static_transform_publisher x y z yaw pitch roll (或 qx qy qz qw) frame_id child_frame_id period_in_ms   # 静态发布两个坐标系之间的关系</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS基础：通讯和回调函数</title>
    <url>/2021/07/18/ROS%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><p>ROS将每个进程看做一个节点，使用节点管理器进行统一管理，并提供一套响应的消息传递机制。在ROS中，所有的消息通信都必须使用节点管理器。ROS的特殊性主要体现在消息通讯层，而不是更深的层次。点对点的连接和配置通过XMLRPC机制实现；节点间的数据流通过网络套接字实现，数据流在ROS中被称为消息，模块间的消息传递采用简单的、语言无关的接口定义描述。</p>
<p>ROS的底层的通信是通过HTTP完成的，因此ROS内核本质上是有一个HTTP服务器，它的地址一般是 <code>http://localhost:11311/</code>，即本地的11311端口，当需要连接到另一台计算机上运行的ROS时，只要连上该机的11311端口即可。</p>
<p>ROS提供多种类型的通讯机制，包括基于主题的异步数据流通信、基于服务的同步RPC（远程过程调用）通信以及基于参数服务的数据传递，支持实现不同需求的网络连接。</p>
<h4 id="基于主题的异步数据流通信"><a href="#基于主题的异步数据流通信" class="headerlink" title="基于主题的异步数据流通信"></a>基于主题的异步数据流通信</h4><p>ROS中最主要的通信方式，它实现了节点间多对多的连接，并且采用单向数据流传输数据。通过主题可以实现发布者和订阅者之间的解耦。底层依赖于XMLRPC和TCP/UDP。步骤如下：</p>
<ol>
<li>talker注册（XMLRPC）</li>
<li>listener注册（XMLRPC）</li>
<li>ros master信息匹配，并将结果返回给listener（XMLRPC）</li>
<li>listener请求talker（RPC地址请求）</li>
<li>talker确认连接请求（RPC回复，结果中包含talker的TCP地址）</li>
<li>listener与talker建立网络连接（TCP）</li>
<li>talker向listener发布数据（TCP）</li>
</ol>
<p>步骤1-5，使用的都是XMLRPC通信，其中步骤4和5，talker和listener会协商共同支持的协议（TCPROS或UDPROS），最后6-7才是真正的TCP或UDP通讯。</p>
<p><strong>XMLRPC</strong>：ROS节点之间建立连接过程及其与master之间通信均使用XMLRPC（基于XML的远程过程调用），这些远程过程调用采用HTTP传输协议，XML作为传输数据的编码格式。XML的文本属性使得它独立于传输层的编码形式，直接封装在HTTP中传输。远程过程调用的主要作用是负责节点对计算图级中的信息进行获取、更改及一些全局变量的设置，不直接支持数据的流传输。</p>
<p><strong>TCPROS和UDPROS</strong>：ROS主题通讯支持TCPROS和UDPROS两种通信协议，TCPROS采用标准的TCP/IP套接字，这是ROS默认的传输方式；UDPROS采用标准的UDP传输方式，它是一种低延时、高效率的传输方式，但可能产生数据丢失，所以它比较适用于远程操作任务。</p>
<h4 id="基于服务的同步RPC通信"><a href="#基于服务的同步RPC通信" class="headerlink" title="基于服务的同步RPC通信"></a>基于服务的同步RPC通信</h4><p>可以实现一对一的连接，采用请求应答的模型。步骤如下：</p>
<ol>
<li>talker注册（XMLRPC）</li>
<li>listener注册（XMLRPC）</li>
<li>ros master信息匹配，并将结果返回给listener（XMLRPC）</li>
<li>listener与talker建立网络连接（TCP）</li>
<li>talker向listener发布数据（TCP）</li>
</ol>
<p>可以看到，相比基于主题的异步数据流通信，该过程少了双方协商协议的过程，因为同步RPC通讯只支持TCPROS，客户端不需要通过XMLRPC与服务端协商共同支持的协议。</p>
<h4 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h4><p>参数服务器是一个可以通过网络访问的多元共享的参数字典，节点在运行时可以在参数服务器上存储或获取参数。参数服务器运行在节点管理器上，它的应用程序编程接口通过XMLRPC库进行访问。可以理解成ROS中的全局变量，只需要XMLRPC通讯，不用TCP，操作如下：</p>
<ol>
<li>talker设置参数</li>
<li>listener查询参数</li>
<li>master将查询结果返回给listener</li>
</ol>
<h4 id="动作action通讯"><a href="#动作action通讯" class="headerlink" title="动作action通讯"></a>动作action通讯</h4><p>带有响应机制的服务。相比于服务的阻塞特性，动作可以在服务端任务执行的过程中，反馈给客户端任务执行的状态，便于客户端查看进度并根据反馈结果作出合理响应。</p>
<h4 id="优缺点和注意事项"><a href="#优缺点和注意事项" class="headerlink" title="优缺点和注意事项"></a>优缺点和注意事项</h4><p>整体来讲，topic适合数据传输，service适合逻辑处理，action用在需要监视的场景，如实际机器人的轨迹执行。一般使用时都不会有问题，毕竟ROS还是一个很好的工具。但是如果数据量比较大或者回调函数运行时间很长，延时一般就不能忽略，此时就涉及到通讯中的回调函数的处理。</p>
<h3 id="回调函数和多线程"><a href="#回调函数和多线程" class="headerlink" title="回调函数和多线程"></a><a href="https://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning">回调函数和多线程</a></h3><p>在基于服务的通信中，客户端和服务端的连接每次都会经历一个查找和连接的过程，而且连接仅在此次服务调用期间有效，在调用返回后将被关闭。服务端回调函数每次只处理客户端发送的数据，并不需要维持一个回调函数队列，而且服务端和客户端的api中并没有回调函数队列长度参数。</p>
<p>但是在基于主题的异步数据流通讯中，订阅者无法确定消息的到达时间，所以利用回调函数，把响应收到消息事件的代码放到回调函数里。通过轮转函数实现回调函数的调用，从而实现消息处理。</p>
<p>ROS提供了三种形式的回调函数队列，分别是：</p>
<ol>
<li>每个订阅者的回调函数队列</li>
<li>每个NodeHandle的回调函数队列</li>
<li>全局回调函数队列，即节点的回调函数队列</li>
</ol>
<p>其中全局回调函数队列在创建节点时自动创建，前两种需要手动创建。当消息到达时，先查看订阅者回调队列，在查看NodeHandle回调队列，最后才查看全局回调队列。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>ros::spin()会导致用户编写的所有回调函数都被调用，并且一旦被调用，将不会返回，除非被关闭。使用ros::spin时，一般在初始化时，都设置好了所有消息的回调函数，并且不需要其他辅助程序运行。</p>
<p>ros::spinOnce调用后会及时返回，并且还可以继续执行之后的程序。它会在某个时间段内及时调用<strong>所有的回调函数</strong>。一般还需要其他辅助程序的执行，如定时任务，数据处理，用户界面等。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>ros::MulitiThreadSpinner，阻塞执行轮转，与ros::spin类似，执行后无需返回，直到节点被关闭。</p>
<p>ros::AsyncSpinner: 没有使用阻塞形式，而是包含了start和stop调用，这样编程人员可以随时打开或者停止在回调函数队列上的轮转，实际使用中，这个更有用。</p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
</search>
